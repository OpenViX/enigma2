diff --git a/configure.ac b/configure.ac
index e707ec9add..d01adc19f6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -625,6 +625,8 @@ lib/python/Plugins/SystemPlugins/DefaultServicesScanner/Makefile
 lib/python/Plugins/SystemPlugins/DefaultServicesScanner/meta/Makefile
 lib/python/Plugins/SystemPlugins/DiseqcTester/Makefile
 lib/python/Plugins/SystemPlugins/DiseqcTester/meta/Makefile
+lib/python/Plugins/SystemPlugins/FastChannelChange/Makefile
+lib/python/Plugins/SystemPlugins/FastChannelChange/meta/Makefile
 lib/python/Plugins/SystemPlugins/FastScan/Makefile
 lib/python/Plugins/SystemPlugins/FrontprocessorUpgrade/Makefile
 lib/python/Plugins/SystemPlugins/FrontprocessorUpgrade/meta/Makefile
diff --git a/lib/dvb/Makefile.inc b/lib/dvb/Makefile.inc
index 96633c0346..5fbdcb7b75 100644
--- a/lib/dvb/Makefile.inc
+++ b/lib/dvb/Makefile.inc
@@ -35,7 +35,9 @@ dvb_libenigma_dvb_a_SOURCES = \
 	dvb/streamserver.cpp \
 	dvb/pmtparse.cpp \
 	dvb/encoder.cpp \
-	dvb/atsc.cpp
+	dvb/atsc.cpp \
+	dvb/fcc.cpp \
+	dvb/fccdecoder.cpp
 
 dvbincludedir = $(pkgincludedir)/lib/dvb
 dvbinclude_HEADERS = \
@@ -79,4 +81,6 @@ dvbinclude_HEADERS = \
 	dvb/streamserver.h \
 	dvb/pmtparse.h \
 	dvb/encoder.h \
-	dvb/atsc.h
+	dvb/atsc.h \
+	dvb/fcc.h \
+	dvb/fccdecoder.h
diff --git a/lib/dvb/decoder.cpp b/lib/dvb/decoder.cpp
index f361a72abc..95f5609dd9 100644
--- a/lib/dvb/decoder.cpp
+++ b/lib/dvb/decoder.cpp
@@ -16,6 +16,8 @@
 #include <sys/stat.h>
 #include <errno.h>
 
+#include <lib/dvb/fccdecoder.h>
+
 #ifndef VIDEO_SOURCE_HDMI
 #define VIDEO_SOURCE_HDMI 2
 #endif
@@ -263,8 +265,8 @@ DEFINE_REF(eDVBVideo);
 
 int eDVBVideo::m_close_invalidates_attributes = -1;
 
-eDVBVideo::eDVBVideo(eDVBDemux *demux, int dev)
-	: m_demux(demux), m_dev(dev),
+eDVBVideo::eDVBVideo(eDVBDemux *demux, int dev, bool fcc_enable)
+	: m_demux(demux), m_dev(dev), m_fcc_enable(fcc_enable),
 	m_width(-1), m_height(-1), m_framerate(-1), m_aspect(-1), m_progressive(-1), m_gamma(-1)
 {
 	char filename[128] = {};
@@ -345,6 +347,9 @@ eDVBVideo::eDVBVideo(eDVBDemux *demux, int dev)
 
 int eDVBVideo::startPid(int pid, int type)
 {
+	if (m_fcc_enable)
+		return 0;
+
 	if (m_fd >= 0)
 	{
 		int streamtype = VIDEO_STREAMTYPE_MPEG2;
@@ -440,6 +445,9 @@ int eDVBVideo::startPid(int pid, int type)
 
 void eDVBVideo::stop()
 {
+	if (m_fcc_enable)
+		return;
+
 	if (m_fd_demux >= 0)
 	{
 		eDebugNoNewLineStart("[eDVBVideo%d] DEMUX_STOP  ", m_dev);
@@ -958,7 +966,7 @@ int eTSMPEGDecoder::setState()
 	{
 		if ((m_vpid >= 0) && (m_vpid < 0x1FFF))
 		{
-			m_video = new eDVBVideo(m_demux, m_decoder);
+			m_video = new eDVBVideo(m_demux, m_decoder, m_fcc_enable);
 			m_video->connectEvent(sigc::mem_fun(*this, &eTSMPEGDecoder::video_event), m_video_event_conn);
 			if (m_video->startPid(m_vpid, m_vtype))
 				res = -1;
@@ -1073,7 +1081,8 @@ RESULT eTSMPEGDecoder::setAC3Delay(int delay)
 eTSMPEGDecoder::eTSMPEGDecoder(eDVBDemux *demux, int decoder)
 	: m_demux(demux),
 		m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
-		m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
+		m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp)),
+		m_fcc_fd(-1), m_fcc_enable(false), m_fcc_state(fcc_state_stop), m_fcc_feid(-1), m_fcc_vpid(-1), m_fcc_vtype(-1), m_fcc_pcrpid(-1)
 {
 	if (m_demux)
 	{
@@ -1099,6 +1108,8 @@ eTSMPEGDecoder::~eTSMPEGDecoder()
 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
 	m_changed = -1;
 	setState();
+	fccStop();
+	fccFreeFD();
 
 	if (m_demux && m_decoder == 0)	// Tuxtxt caching actions only on primary decoder
 	{
@@ -1456,3 +1467,240 @@ int eTSMPEGDecoder::getVideoGamma()
 		return m_video->getGamma();
 	return -1;
 }
+
+#define FCC_SET_VPID 100
+#define FCC_SET_APID 101
+#define FCC_SET_PCRPID 102
+#define FCC_SET_VCODEC 103
+#define FCC_SET_ACODEC 104
+#define FCC_SET_FRONTEND_ID 105
+#define FCC_START 106
+#define FCC_STOP 107
+#define FCC_DECODER_START 108
+#define FCC_DECODER_STOP 109
+
+RESULT eTSMPEGDecoder::prepareFCC(int fe_id, int vpid, int vtype, int pcrpid)
+{
+	//eDebug("[eTSMPEGDecoder] prepareFCC vp : %d, vt : %d, pp : %d, fe : %d", vpid, vtype, pcrpid, fe_id); 
+
+	if ((fccGetFD() == -1) || (fccSetPids(fe_id, vpid, vtype, pcrpid) < 0) || (fccStart() < 0))
+	{
+		fccFreeFD();
+		return -1;
+	}
+
+	m_fcc_enable = true;
+
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccDecoderStart()
+{
+	if (m_fcc_fd == -1)
+		return -1;
+
+	if (m_fcc_state != fcc_state_ready)
+	{
+		eDebug("[eTSMPEGDecoder] FCC decoder is already in decoding state.");
+		return 0;
+	}
+
+	if (ioctl(m_fcc_fd, FCC_DECODER_START) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] ioctl FCC_DECODER_START failed! (%m)");
+		return -1;
+	}
+
+	m_fcc_state = fcc_state_decoding;
+
+	eDebug("[eTSMPEGDecoder] FCC_DECODER_START OK!");
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccDecoderStop()
+{
+	if (m_fcc_fd == -1)
+		return -1;
+
+	if (m_fcc_state != fcc_state_decoding)
+	{
+		eDebug("[eTSMPEGDecoder] FCC decoder is not in decoding state.");
+	}
+	else if (ioctl(m_fcc_fd, FCC_DECODER_STOP) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] ioctl FCC_DECODER_STOP failed! (%m)");
+		return -1;
+	}
+
+	m_fcc_state = fcc_state_ready;
+
+	/* stop pcr, video, audio, text */
+	finishShowSinglePic();
+
+	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
+	m_changed = -1;
+	setState();
+
+	eDebug("[eTSMPEGDecoder] FCC_DECODER_STOP OK!");
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccUpdatePids(int fe_id, int vpid, int vtype, int pcrpid)
+{
+	//eDebug("[eTSMPEGDecoder] vp : %d, vt : %d, pp : %d, fe : %d", vpid, vtype, pcrpid, fe_id);
+
+	if ((fe_id != m_fcc_feid) || (vpid != m_fcc_vpid) || (vtype != m_fcc_vtype) || (pcrpid != m_fcc_pcrpid))
+	{
+		fccStop();
+		if (prepareFCC(fe_id, vpid, vtype, pcrpid))
+		{
+			eDebug("[eTSMPEGDecoder] prepare FCC failed!");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccStart()
+{
+	if (m_fcc_fd == -1)
+		return -1;
+
+	if (m_fcc_state != fcc_state_stop)
+	{
+		eDebug("[eTSMPEGDecoder] FCC is already started!");
+		return 0;
+	}
+	else if (ioctl(m_fcc_fd, FCC_START) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] ioctl FCC_START failed! (%m)");
+		return -1;
+	}
+
+	eDebug("[eTSMPEGDecoder] FCC_START OK!");
+
+	m_fcc_state = fcc_state_ready;
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccStop()
+{
+	if (m_fcc_fd == -1)
+		return -1;
+
+	if (m_fcc_state == fcc_state_stop)
+	{
+		eDebug("[eTSMPEGDecoder] FCC is already stopped!");
+		return 0;
+	}
+
+	else if (m_fcc_state == fcc_state_decoding)
+	{
+		fccDecoderStop();
+	}
+
+	if (ioctl(m_fcc_fd, FCC_STOP) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] ioctl FCC_STOP failed! (%m)");
+		return -1;
+	}
+
+	m_fcc_state = fcc_state_stop;
+
+	eDebug("[eTSMPEGDecoder] FCC_STOP OK!");
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccSetPids(int fe_id, int vpid, int vtype, int pcrpid)
+{
+	int streamtype = VIDEO_STREAMTYPE_MPEG2;
+
+	if (m_fcc_fd == -1)
+		return -1;
+
+	if (ioctl(m_fcc_fd, FCC_SET_FRONTEND_ID, fe_id) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] FCC_SET_FRONTEND_ID failed! (%m)");
+		return -1;
+	}
+
+	else if(ioctl(m_fcc_fd, FCC_SET_PCRPID, pcrpid) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] FCC_SET_PCRPID failed! (%m)");
+		return -1;
+	}
+
+	else if (ioctl(m_fcc_fd, FCC_SET_VPID, vpid) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] FCC_SET_VPID failed! (%m)");
+		return -1;
+	}
+
+	switch(vtype)
+	{
+		default:
+		case eDVBVideo::MPEG2:
+			break;
+		case eDVBVideo::MPEG4_H264:
+			streamtype = VIDEO_STREAMTYPE_MPEG4_H264;
+			break;
+		case eDVBVideo::MPEG1:
+			streamtype = VIDEO_STREAMTYPE_MPEG1;
+			break;
+		case eDVBVideo::MPEG4_Part2:
+			streamtype = VIDEO_STREAMTYPE_MPEG4_Part2;
+			break;
+		case eDVBVideo::VC1:
+			streamtype = VIDEO_STREAMTYPE_VC1;
+			break;
+		case eDVBVideo::VC1_SM:
+			streamtype = VIDEO_STREAMTYPE_VC1_SM;
+			break;
+		case eDVBVideo::H265_HEVC:
+			streamtype = VIDEO_STREAMTYPE_H265_HEVC;
+			break;
+	}
+
+	if(ioctl(m_fcc_fd, FCC_SET_VCODEC, streamtype) < 0)
+	{
+		eDebug("[eTSMPEGDecoder] FCC_SET_VCODEC failed! (%m)");
+		return -1;
+	}
+
+	m_fcc_feid = fe_id;
+	m_fcc_vpid = vpid;
+	m_fcc_vtype = vtype;
+	m_fcc_pcrpid = pcrpid;
+
+	//eDebug("[eTSMPEGDecoder] SET PIDS OK!");
+	return 0;
+}
+
+RESULT eTSMPEGDecoder::fccGetFD()
+{
+	if (m_fcc_fd == -1)
+	{
+		eFCCDecoder* fcc = eFCCDecoder::getInstance();
+		if (fcc != NULL)
+		{
+			m_fcc_fd = fcc->allocateFcc();
+		}
+	}
+
+	return m_fcc_fd;
+}
+
+RESULT eTSMPEGDecoder::fccFreeFD()
+{
+	if (m_fcc_fd != -1)
+	{
+		eFCCDecoder* fcc = eFCCDecoder::getInstance();
+		if (fcc != NULL)
+		{
+			fcc->freeFcc(m_fcc_fd);
+			m_fcc_fd = -1;
+		}
+	}
+
+	return 0;
+}
diff --git a/lib/dvb/decoder.h b/lib/dvb/decoder.h
index c99644fe9b..05cb4d4ea4 100644
--- a/lib/dvb/decoder.h
+++ b/lib/dvb/decoder.h
@@ -32,6 +32,7 @@ class eDVBVideo: public iObject, public sigc::trackable
 private:
 	ePtr<eDVBDemux> m_demux;
 	int m_fd, m_fd_demux, m_dev;
+	bool m_fcc_enable;
 	static int m_close_invalidates_attributes;
 	int m_is_slow_motion, m_is_fast_forward, m_is_freezed;
 	ePtr<eSocketNotifier> m_sn;
@@ -41,7 +42,7 @@ private:
 	static int readApiSize(int fd, int &xres, int &yres, int &aspect);
 public:
 	enum { UNKNOWN = -1, MPEG2, MPEG4_H264, VC1 = 3, MPEG4_Part2, VC1_SM, MPEG1, H265_HEVC, AVS = 16, AVS2 = 40 };
-	eDVBVideo(eDVBDemux *demux, int dev);
+	eDVBVideo(eDVBDemux *demux, int dev, bool fcc_enable=false);
 	void stop();
 	int startPid(int pid, int type=MPEG2);
 	void flush();
@@ -121,6 +122,13 @@ private:
 	sigc::signal<void(struct videoEvent)> m_video_event;
 	int m_video_clip_fd;
 	ePtr<eTimer> m_showSinglePicTimer;
+	int m_fcc_fd;
+	bool m_fcc_enable;
+	int m_fcc_state;
+	int m_fcc_feid;
+	int m_fcc_vpid;
+	int m_fcc_vtype;
+	int m_fcc_pcrpid;
 	void finishShowSinglePic(); // called by timer
 public:
 	enum { pidNone = -1 };
@@ -177,6 +185,23 @@ public:
 	int getVideoGamma();
 	static RESULT setHwPCMDelay(int delay);
 	static RESULT setHwAC3Delay(int delay);
+
+	enum 
+	{
+		fcc_state_stop,
+		fcc_state_ready,
+		fcc_state_decoding
+	};
+
+	RESULT prepareFCC(int fe_id, int vpid, int vtype, int pcrpid);
+	RESULT fccStart();
+	RESULT fccStop();
+	RESULT fccDecoderStart();
+	RESULT fccDecoderStop();
+	RESULT fccUpdatePids(int fe_id, int vpid, int vtype, int pcrpid);
+	RESULT fccSetPids(int fe_id, int vpid, int vtype, int pcrpid);
+	RESULT fccGetFD();
+	RESULT fccFreeFD();
 };
 
 #endif
diff --git a/lib/dvb/dvb.cpp b/lib/dvb/dvb.cpp
index df2babf964..1033387f89 100644
--- a/lib/dvb/dvb.cpp
+++ b/lib/dvb/dvb.cpp
@@ -11,6 +11,7 @@
 #include <lib/dvb/dvb.h>
 #include <lib/dvb/sec.h>
 #include <lib/dvb/fbc.h>
+#include <lib/dvb/fcc.h>
 #include <lib/dvb/specs.h>
 #include "filepush.h"
 
@@ -20,6 +21,7 @@
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/ioctl.h>
+#include <fstream>
 
 #define MIN(a,b) (a < b ? a : b)
 #define MAX(a,b) (a > b ? a : b)
@@ -111,6 +113,9 @@ eDVBResourceManager::eDVBResourceManager()
 		adapter->scanDevices();
 		addAdapter(adapter, true);
 	}
+
+	setUsbTuner();
+
 	eDebug("[eDVBResourceManager] found %zd adapter, %zd frontends(%zd sim) and %zd demux",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size());
 	m_fbcmng = new eFBCTunerManager(instance);
@@ -682,6 +687,59 @@ void eDVBResourceManager::addAdapter(iDVBAdapter *adapter, bool front)
 
 }
 
+void eDVBResourceManager::setUsbTuner()
+{
+	std::ifstream in("/proc/bus/nim_sockets");
+	std::string line;
+
+	int res = -1;
+	int fe_idx = -1;
+	int usbtuner_idx[8] = {0};
+	int usbtuner_count = 0;
+
+	if (in.is_open())
+	{
+		while(!in.eof())
+		{
+			getline(in, line);
+			if ((res = sscanf(line.c_str(), "NIM Socket %d:", &fe_idx)) == 1)
+				continue;
+
+			if ((fe_idx != -1) && (line.find("\tName: ") == 0) && (line.find("VTUNER") != std::string::npos))
+				usbtuner_idx[usbtuner_count++] = fe_idx;
+		}
+		in.close();
+	}
+
+	if (usbtuner_count)
+	{
+		for (eSmartPtrList<eDVBRegisteredFrontend>::iterator it(m_frontend.begin()); it != m_frontend.end(); ++it)
+		{
+			int slotid = it->m_frontend->getSlotID();
+			for (int i=0; i < usbtuner_count ; i++)
+			{
+				if (slotid == usbtuner_idx[i])
+				{
+					it->m_frontend->setUSBTuner(true);
+					break;
+				}
+			}
+		}
+		for (eSmartPtrList<eDVBRegisteredFrontend>::iterator it(m_simulate_frontend.begin()); it != m_simulate_frontend.end(); ++it)
+		{
+			int slotid = it->m_frontend->getSlotID();
+			for (int i=0; i < usbtuner_count ; i++)
+			{
+				if (slotid == usbtuner_idx[i])
+				{
+					it->m_frontend->setUSBTuner(true);
+					break;
+				}
+			}
+		}
+	}
+}
+
 PyObject *eDVBResourceManager::setFrontendSlotInformations(ePyObject list)
 {
 	if (!PyList_Check(list))
@@ -1407,6 +1465,56 @@ int eDVBResourceManager::canAllocateChannel(const eDVBChannelID &channelid, cons
 	int *decremented_cached_channel_fe_usecount=NULL,
 		*decremented_fe_usecount=NULL;
 
+	/* check FCC channels */
+	std::vector<int*> fcc_decremented_fe_usecounts;
+	std::map<eDVBChannelID, int> fcc_chids;
+	int apply_to_ignore = 0;
+	if (!eFCCServiceManager::getFCCChannelID(fcc_chids))
+	{
+		for (std::map<eDVBChannelID, int>::iterator i(fcc_chids.begin()); i != fcc_chids.end(); ++i)
+		{
+			//eDebug("[eDVBResourceManager::canAllocateChannel] FCC NS : %08x, TSID : %04x, ONID : %04x", i->first.dvbnamespace.get(), i->first.transport_stream_id.get(), i->first.original_network_id.get());
+			if (ignore == i->first)
+			{
+				apply_to_ignore = i->second;
+				continue;
+			}
+			for (std::list<active_channel>::iterator ii(active_channels.begin()); ii != active_channels.end(); ++ii)
+			{
+				eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
+				if (ii->m_channel_id == i->first)
+				{
+					eDVBChannel *channel = (eDVBChannel*) &(*ii->m_channel);
+
+					int check_usecount = channel == &(*m_cached_channel) ? 1 : 0;
+					check_usecount += i->second * 2; // one is used in eDVBServicePMTHandler and another is used in eDVBScan.
+					//eDebug("[eDVBResourceManager::canAllocateChannel] channel->getUseCount() : %d , check_usecount : %d (cached : %d)", channel->getUseCount(), check_usecount, channel == &(*m_cached_channel));
+					if (channel->getUseCount() == check_usecount)
+					{
+						ePtr<iDVBFrontend> fe;
+						if (!ii->m_channel->getFrontend(fe))
+						{
+							for (eSmartPtrList<eDVBRegisteredFrontend>::iterator iii(frontends.begin()); iii != frontends.end(); ++iii)
+							{
+								if ( &(*fe) == &(*iii->m_frontend) )
+								{
+									//eDebug("[eDVBResourceManager::canAllocateChannel] fcc : decrease fcc fe use_count! feid : %d (%d -> %d)", iii->m_frontend->getSlotID(), iii->m_inuse, iii->m_inuse-1);
+									--iii->m_inuse;
+									int *tmp_decremented_fe_usecount = &iii->m_inuse;
+									fcc_decremented_fe_usecounts.push_back(tmp_decremented_fe_usecount);
+									if (channel == &(*m_cached_channel))
+										decremented_cached_channel_fe_usecount = tmp_decremented_fe_usecount;
+									break;
+								}
+							}
+						}
+					}
+					break;
+				}
+			}
+		}
+	}
+
 	for (std::list<active_channel>::iterator i(active_channels.begin()); i != active_channels.end(); ++i)
 	{
 		eSmartPtrList<eDVBRegisteredFrontend> &frontends = simulate ? m_simulate_frontend : m_frontend;
@@ -1418,7 +1526,10 @@ int eDVBResourceManager::canAllocateChannel(const eDVBChannelID &channelid, cons
 			// another on eUsePtr<iDVBChannel> is used in the eDVBScan instance used in eDVBServicePMTHandler (for SDT scan)
 			// so we must check here if usecount is 3 (when the channel is equal to the cached channel)
 			// or 2 when the cached channel is not equal to the compared channel
-			if (channel == &(*m_cached_channel) ? channel->getUseCount() == 3 : channel->getUseCount() == 2)  // channel only used once..
+			int check_usecount = channel == &(*m_cached_channel) ? 1 : 0;
+			check_usecount += (apply_to_ignore+1) * 2; // one is used in eDVBServicePMTHandler and another is used in eDVBScan.
+			//eDebug("[eDVBResourceManager] canAllocateChannel channel->getUseCount() : %d , check_usecount : %d (cached : %d)", channel->getUseCount(), check_usecount, channel == &(*m_cached_channel));
+			if (channel->getUseCount() == check_usecount)  // channel only used once..(except fcc)
 			{
 				ePtr<iDVBFrontend> fe;
 				if (!i->m_channel->getFrontend(fe))
@@ -1427,6 +1538,7 @@ int eDVBResourceManager::canAllocateChannel(const eDVBChannelID &channelid, cons
 					{
 						if ( &(*fe) == &(*ii->m_frontend) )
 						{
+							//eDebug("[eDVBResourceManager] canAllocateChannel ignore : decrease fcc fe use_count! feid : %d (%d -> %d)", ii->m_frontend->getSlotID(), ii->m_inuse, ii->m_inuse-1);
 							--ii->m_inuse;
 							decremented_fe_usecount = &ii->m_inuse;
 							if (channel == &(*m_cached_channel))
@@ -1489,6 +1601,14 @@ error:
 		++(*decremented_fe_usecount);
 	if (decremented_cached_channel_fe_usecount)
 		++(*decremented_cached_channel_fe_usecount);
+	if (fcc_decremented_fe_usecounts.size())
+	{
+		for (std::vector<int*>::iterator i(fcc_decremented_fe_usecounts.begin()); i != fcc_decremented_fe_usecounts.end(); ++i)
+		{
+			//eDebug("[eDVBResourceManager] canAllocateChannel fcc : increase fcc fe use_count!");
+			++(**i);
+		}
+	}
 
 	return ret;
 }
diff --git a/lib/dvb/dvb.h b/lib/dvb/dvb.h
index f2f2e82404..238c37d302 100644
--- a/lib/dvb/dvb.h
+++ b/lib/dvb/dvb.h
@@ -166,6 +166,7 @@ class eDVBResourceManager: public iObject, public sigc::trackable
 	eSmartPtrList<eDVBRegisteredDemux> m_demux;
 	eSmartPtrList<eDVBRegisteredFrontend> m_frontend, m_simulate_frontend;
 	void addAdapter(iDVBAdapter *adapter, bool front = false);
+	void setUsbTuner();
 
 	struct active_channel
 	{
diff --git a/lib/dvb/fcc.cpp b/lib/dvb/fcc.cpp
new file mode 100644
index 0000000000..4c52613581
--- /dev/null
+++ b/lib/dvb/fcc.cpp
@@ -0,0 +1,378 @@
+#include <lib/dvb/fcc.h>
+#include <lib/nav/core.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/eerror.h>
+#include <lib/python/python.h>
+
+//#define FCC_DEBUG
+
+void FCCServiceChannels::addFCCService(const eServiceReference &service)
+{
+	eDVBChannelID fcc_chid;
+
+	((const eServiceReferenceDVB&)service).getChannelID(fcc_chid);
+
+	if (m_fcc_chids.find(fcc_chid) != m_fcc_chids.end())
+		m_fcc_chids[fcc_chid] += 1;
+	else
+		m_fcc_chids[fcc_chid] = 1;
+}
+
+void FCCServiceChannels::removeFCCService(const eServiceReference &service)
+{
+	eDVBChannelID fcc_chid;
+	((const eServiceReferenceDVB&)service).getChannelID(fcc_chid);
+
+	if (m_fcc_chids.find(fcc_chid) != m_fcc_chids.end())
+	{
+		m_fcc_chids[fcc_chid] -= 1;
+
+		if (m_fcc_chids[fcc_chid] == 0)
+			m_fcc_chids.erase(fcc_chid);
+	}
+}
+
+int FCCServiceChannels::getFCCChannelID(std::map<eDVBChannelID, int> &fcc_chids)
+{
+	if (!m_fcc_chids.size()) return -1;
+
+	fcc_chids = m_fcc_chids;
+	return 0;
+}
+
+eFCCServiceManager *eFCCServiceManager::m_instance = (eFCCServiceManager*)0;
+
+eFCCServiceManager* eFCCServiceManager::getInstance()
+{
+	return m_instance;
+}
+
+eFCCServiceManager::eFCCServiceManager(eNavigation *navptr)
+	:m_core(navptr), m_fcc_enable(false)
+{
+	if (!m_instance)
+	{
+		m_instance = this;
+	}
+}
+
+eFCCServiceManager::~eFCCServiceManager()
+{
+	if (m_instance == this)
+	{
+		m_instance = 0;
+	}
+}
+
+RESULT eFCCServiceManager::playFCCService(const eServiceReference &ref, ePtr<iPlayableService> &service)
+{
+	std::map< ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+	for (;it != m_FCCServices.end();++it)
+	{
+		ASSERT (ref != it->second.m_service_reference);
+	}
+
+	ASSERT(m_core->m_servicehandler);
+	RESULT res = m_core->m_servicehandler->play(ref, service);
+	if (res)
+		service = 0;
+	else
+	{
+		ePtr<eConnection> conn;
+		service->connectEvent(sigc::mem_fun(*this, &eFCCServiceManager::FCCEvent), conn);
+
+		FCCServiceElem elem = {ref, conn, fcc_state_preparing, false};
+		m_FCCServices[service] = elem;
+
+		res = service->start();
+	}
+
+	printFCCServices();
+
+	return res;
+}
+
+void eFCCServiceManager::FCCEvent(iPlayableService* service, int event)
+{
+	std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.find(service);
+	if (it == m_FCCServices.end())
+	{
+		eDebug("[eFCCServiceManager] Event for non registered FCC service");
+		return;
+	}
+
+	switch (event)
+	{
+		case iPlayableService::evStart:
+		{
+			m_fccServiceChannels.addFCCService(it->second.m_service_reference);
+			break;
+		}
+		case iPlayableService::evStopped:
+		{
+			m_fccServiceChannels.removeFCCService(it->second.m_service_reference);
+			break;
+		}
+		case iPlayableService::evTuneFailed:
+		case iPlayableService::evFccFailed:
+		{
+			eDebug("[eFCCServiceManager] FCCEvent [%s] set service to state failed.", it->second.m_service_reference.toString().c_str());
+			it->second.m_state = fcc_state_failed;
+			break;
+		}
+	}
+	m_fcc_event(event);
+}
+
+RESULT eFCCServiceManager::cleanupFCCService()
+{
+	if (m_FCCServices.size())
+	{
+		std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+		for (;it != m_FCCServices.end();++it)
+		{
+			eDebug("[eFCCServiceManager] Stop FCC service sref : %s", it->second.m_service_reference.toString().c_str());
+			it->first->stop();
+		}
+
+		m_FCCServices.clear();
+	}
+	return 0;
+}
+
+RESULT eFCCServiceManager::stopFCCService(const eServiceReference &sref)
+{
+	if (m_FCCServices.size())
+	{
+		std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+		for (; it != m_FCCServices.end();)
+		{
+			if (it->second.m_service_reference == sref)
+			{
+				eDebug("[eFCCServiceManager] Stop FCC service sref : %s", it->second.m_service_reference.toString().c_str());
+				it->first->stop();
+				m_FCCServices.erase(it++);
+			}
+			else
+			{
+				++it;
+			}
+		}
+		printFCCServices();
+	}
+	return 0;
+}
+
+RESULT eFCCServiceManager::stopFCCService()
+{
+	if (m_FCCServices.size())
+	{
+		std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+		for (; it != m_FCCServices.end();)
+		{
+			if (it->second.m_state == fcc_state_failed)
+			{
+				eDebug("[eFCCServiceManager] Stop FCC service sref : %s", it->second.m_service_reference.toString().c_str());
+				it->first->stop();
+				m_FCCServices.erase(it++);
+			}
+			else
+			{
+				++it;
+			}
+		}
+
+		printFCCServices();
+	}
+	return 0;
+}
+
+RESULT eFCCServiceManager::tryFCCService(const eServiceReference &sref, ePtr<iPlayableService> &service)
+{
+	if (!isEnable())
+		return -1;
+
+	ePtr<iPlayableService> new_service = 0;
+
+	printFCCServices();
+
+	int get_fcc_decoding = 0;
+
+	/* stop previous decoding service */
+	std::map< ePtr<iPlayableService>, FCCServiceElem >::iterator it;
+	for (it = m_FCCServices.begin();it != m_FCCServices.end();++it)
+	{
+		if (it->second.m_state == fcc_state_decoding)
+		{
+			ASSERT(get_fcc_decoding == 0);
+			get_fcc_decoding = 1;
+
+			/* send end event */
+			m_core->m_event(iPlayableService::evEnd);
+
+			/* kill service and event */
+			m_core->m_service_event_conn = 0;
+			m_core->m_runningService = 0;
+
+			if (it->second.m_useNormalDecode)
+			{
+				/* stop service */
+				it->first->stop();
+				m_FCCServices.erase(it++);
+			}
+			else
+			{
+				/* connect to fcc event */
+				ePtr<eConnection> conn;
+				it->first->connectEvent(sigc::mem_fun(*this, &eFCCServiceManager::FCCEvent), conn);
+				it->second.m_service_event_conn = conn;
+				it->second.m_state = fcc_state_preparing;
+
+				/* switch to FCC prepare state */
+				it->first->start();
+
+				/* update FCCServiceChannels */
+				m_fccServiceChannels.addFCCService(it->second.m_service_reference);
+			}
+			break;
+		}
+	}
+
+	/* search new service */
+	for (it = m_FCCServices.begin();it != m_FCCServices.end();++it)
+	{
+		if (it->second.m_service_reference == sref)
+		{
+			eDebug("[eFCCServiceManager] Use FCC service sref : %s", it->second.m_service_reference.toString().c_str());
+			it->second.m_service_event_conn = 0; /* disconnect FCC event */
+			it->second.m_state = fcc_state_decoding;
+			new_service = it->first;
+			m_fccServiceChannels.removeFCCService(it->second.m_service_reference);
+			break;
+		}
+	}
+
+	if (new_service)
+	{
+		service = new_service;
+	}
+
+	else /* If new service is not found in FCC service list, cleanup all FCC prepared services and get new FCC service. */
+	{
+		cleanupFCCService();
+		m_core->stopService();
+		if (eFCCServiceManager::checkAvailable(sref))
+		{
+			ASSERT(m_core->m_servicehandler);
+			m_core->m_servicehandler->play(sref, service);
+
+			if (service)
+			{
+				FCCServiceElem elem = {sref, 0, fcc_state_decoding, false};
+				m_FCCServices[service] = elem;
+				service->start(); // do FCC preparing
+			}
+		}
+		else
+		{
+			return -1;
+		}
+	}
+
+	printFCCServices();
+
+	return 0;
+}
+
+PyObject *eFCCServiceManager::getFCCServiceList()
+{
+	ePyObject dest = PyDict_New();
+	if (dest)
+	{
+		std::map< ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+		for (;it != m_FCCServices.end();++it)
+		{
+			ePyObject tplist = PyList_New(0);
+			PyList_Append(tplist, PyLong_FromLong((long)it->second.m_state));
+			PyList_Append(tplist, PyLong_FromLong((long)isLocked(it->first)));
+			PyDict_SetItemString(dest, it->second.m_service_reference.toString().c_str(), tplist);
+			Py_DECREF(tplist);
+		}
+	}
+
+	else
+		Py_RETURN_NONE;
+	return dest;
+}
+
+int eFCCServiceManager::isLocked(ePtr<iPlayableService> service)
+{
+	ePtr<iFrontendInformation> ptr;
+	service->frontendInfo(ptr);
+	return ptr->getFrontendInfo(iFrontendInformation_ENUMS::lockState);
+}
+
+void eFCCServiceManager::printFCCServices()
+{
+#ifdef FCC_DEBUG
+	eDebug("[eFCCServiceManager] printFCCServices [*] total size : %d", m_FCCServices.size());
+
+	std::map< ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.begin();
+	for (;it != m_FCCServices.end();++it)
+	{
+		int isLocked = isLocked(it->first);
+		eDebug("[eFCCServiceManager] printFCCServices [*] sref : %s, state : %d, tune : %d, useNormalDecode : %d", it->second.m_service_reference.toString().c_str(), it->second.m_state, isLocked, it->second.m_useNormalDecode);
+	}
+#else
+	;
+#endif
+}
+
+int eFCCServiceManager::getFCCChannelID(std::map<eDVBChannelID, int> &fcc_chids)
+{
+	eFCCServiceManager *fcc_mng = eFCCServiceManager::getInstance();
+	if (!fcc_mng) return -1;
+	return fcc_mng->m_fccServiceChannels.getFCCChannelID(fcc_chids);
+}
+
+bool eFCCServiceManager::checkAvailable(const eServiceReference &ref)
+{
+	int serviceType = ref.getData(0);
+	eFCCServiceManager *fcc_mng = eFCCServiceManager::getInstance();
+
+	if ((ref.type == 1) && ref.path.empty() && (serviceType != 2) && (serviceType != 10) && fcc_mng) // no PVR, streaming, radio channel..
+		return fcc_mng->isEnable();
+	return false;
+}
+
+bool eFCCServiceManager::isStateDecoding(iPlayableService* service)
+{
+	std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.find(service);
+	if (it != m_FCCServices.end())
+	{
+		return (it->second.m_state == fcc_state_decoding);
+	}
+	else
+	{
+		eDebug("[eFCCServiceManager] Non registered FCC service");
+	}
+
+	return false;
+}
+
+void eFCCServiceManager::setNormalDecoding(iPlayableService* service)
+{
+	std::map<ePtr<iPlayableService>, FCCServiceElem >::iterator it = m_FCCServices.find(service);
+	if (it != m_FCCServices.end())
+	{
+		eDebug("[eFCCServiceManager] setNormalDecoding [%s] set to use normal decoding.", it->second.m_service_reference.toString().c_str());
+		it->second.m_useNormalDecode = true;
+	}
+	else
+	{
+		eDebug("[eFCCServiceManager] Non registered FCC service");
+	}
+}
+
+DEFINE_REF(eFCCServiceManager);
+
diff --git a/lib/dvb/fcc.h b/lib/dvb/fcc.h
new file mode 100644
index 0000000000..136526a80f
--- /dev/null
+++ b/lib/dvb/fcc.h
@@ -0,0 +1,70 @@
+#ifndef __dvb_fcc_h
+#define __dvb_fcc_h
+
+#include <lib/dvb/idvb.h>
+#include <lib/base/object.h>
+#include <lib/service/iservice.h>
+#include <connection.h>
+
+class eNavigation;
+
+class FCCServiceChannels
+{
+private:
+	std::map<eDVBChannelID, int> m_fcc_chids;
+
+public:
+	void addFCCService(const eServiceReference &service);
+	void removeFCCService(const eServiceReference &service);
+	int getFCCChannelID(std::map<eDVBChannelID, int> &fcc_chids);
+};
+
+typedef struct _tagFccElem
+{
+	eServiceReference m_service_reference;
+	ePtr<eConnection> m_service_event_conn;
+	int m_state;
+	bool m_useNormalDecode;
+}FCCServiceElem;
+
+class eFCCServiceManager: public iObject, public sigc::trackable
+{
+	DECLARE_REF(eFCCServiceManager);
+private:
+	eNavigation *m_core;
+	static eFCCServiceManager* m_instance;
+	std::map<ePtr<iPlayableService>, FCCServiceElem, std::less<iPlayableService*> > m_FCCServices;
+	FCCServiceChannels m_fccServiceChannels;
+
+	bool m_fcc_enable;
+
+	void FCCEvent(iPlayableService* service, int event);
+public:
+	PSignal1<void, int> m_fcc_event;
+	static eFCCServiceManager* getInstance();
+	eFCCServiceManager(eNavigation *navptr);
+	~eFCCServiceManager();
+
+	enum
+	{
+		fcc_state_preparing,
+		fcc_state_decoding,
+		fcc_state_failed
+	};
+	SWIG_VOID(RESULT)  playFCCService(const eServiceReference &ref, ePtr<iPlayableService> &SWIG_OUTPUT);
+	RESULT stopFCCService(const eServiceReference &sref);
+	RESULT stopFCCService();
+	RESULT cleanupFCCService();
+	RESULT tryFCCService(const eServiceReference &service, ePtr<iPlayableService> &ptr);
+	PyObject *getFCCServiceList();
+	void printFCCServices();
+	int isLocked(ePtr<iPlayableService> service);
+	static int getFCCChannelID(std::map<eDVBChannelID, int> &fcc_chids);
+	static bool checkAvailable(const eServiceReference &ref);
+	void setFCCEnable(int enable) { m_fcc_enable = (enable != 0); }
+	bool isEnable() { return m_fcc_enable; }
+	bool isStateDecoding(iPlayableService* service);
+	void setNormalDecoding(iPlayableService* service);
+};
+
+#endif /* __dvb_fcc_h */
diff --git a/lib/dvb/fccdecoder.cpp b/lib/dvb/fccdecoder.cpp
new file mode 100644
index 0000000000..68e9af2a40
--- /dev/null
+++ b/lib/dvb/fccdecoder.cpp
@@ -0,0 +1,75 @@
+#include <lib/dvb/fccdecoder.h>
+#include <lib/base/eerror.h>
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+bool eFCCDecoder::isDestroyed = false;
+eFCCDecoder::eFCCDecoder()
+{
+	int index = 0;
+
+	eDebug("[eFCCDecoder] Scanning for FCC device files..");
+	while(1)
+	{
+		struct stat s;
+		char filename[128];
+		sprintf(filename, "/dev/fcc%d", index);
+		if (stat(filename, &s))
+			break;
+
+		eDebug("[eFCCDecoder] %s found..", filename);
+		m_fccs.push_back(-1);
+		index++;
+	}
+}
+
+eFCCDecoder::~eFCCDecoder()
+{
+	isDestroyed = true;
+}
+
+int eFCCDecoder::allocateFcc()
+{
+	int fccFd = -1;
+	for(unsigned int i = 0; i < m_fccs.size(); i++)
+	{
+		if (m_fccs[i]== -1)
+		{
+			char filename[128];
+			sprintf(filename, "/dev/fcc%d", i);
+
+			fccFd = ::open(filename, O_RDWR);
+			if (fccFd < 0)
+				eDebug("[eFCCDecoder] Open %s failed!", filename);
+
+			else
+				eDebug("[eFCCDecoder] Alloc %s", filename);
+
+			m_fccs[i] = fccFd;
+			break;
+		}
+	}
+
+	return fccFd;
+}
+
+void eFCCDecoder::freeFcc(int fccFd)
+{
+	if (fccFd < 0)
+		return;
+
+	for(unsigned int i = 0; i < m_fccs.size(); i++)
+	{
+		if (m_fccs[i]== fccFd)
+		{
+			m_fccs[i] = -1;
+			eDebug("[eFCCDecoder] Close /dev/fcc%d", i);
+			::close(fccFd);
+			break;
+		}
+	}
+}
+
diff --git a/lib/dvb/fccdecoder.h b/lib/dvb/fccdecoder.h
new file mode 100644
index 0000000000..c7b57c5378
--- /dev/null
+++ b/lib/dvb/fccdecoder.h
@@ -0,0 +1,28 @@
+#ifndef __dvb_fcc_decoder_h
+#define __dvb_fcc_decoder_h
+
+#include <vector>
+
+class eFCCDecoder
+{
+	std::vector<int> m_fccs;
+	static eFCCDecoder *instance;
+	static bool isDestroyed;
+
+public:
+	eFCCDecoder();
+	~eFCCDecoder();
+	int allocateFcc();
+	void freeFcc(int fccFd);
+
+	static eFCCDecoder* getInstance()
+	{
+		if (isDestroyed)
+			return NULL;
+
+		static eFCCDecoder instance;
+		return &instance;
+	}
+};
+
+#endif /* __dvb_fcc_decoder_h */
diff --git a/lib/dvb/frontend.cpp b/lib/dvb/frontend.cpp
index 7982bb9846..3a76b0295b 100644
--- a/lib/dvb/frontend.cpp
+++ b/lib/dvb/frontend.cpp
@@ -556,7 +556,7 @@ int eDVBFrontend::PriorityOrder=0;
 int eDVBFrontend::PreferredFrontendIndex = -1;
 
 eDVBFrontend::eDVBFrontend(const char *devicenodename, int fe, int &ok, bool simulate, eDVBFrontend *simulate_fe)
-	:m_simulate(simulate), m_enabled(false), m_fbc(false), m_simulate_fe(simulate_fe), m_type(-1), m_dvbid(fe), m_slotid(fe)
+	:m_simulate(simulate), m_enabled(false), m_fbc(false), m_is_usbtuner(false), m_simulate_fe(simulate_fe), m_type(-1), m_dvbid(fe), m_slotid(fe)
 	,m_fd(-1), m_dvbversion(0), m_rotor_mode(false), m_need_rotor_workaround(false), m_multitype(false), m_voltage5_terrestrial(-1)
 	,m_state(stateClosed), m_timeout(0), m_tuneTimer(0)
 {
@@ -1584,6 +1584,8 @@ int eDVBFrontend::readFrontendData(int type)
 			return !!(readFrontendData(iFrontendInformation_ENUMS::frontendStatus) & FE_HAS_SYNC);
 		case iFrontendInformation_ENUMS::frontendNumber:
 			return m_slotid;
+		case iFrontendInformation_ENUMS::isUsbTuner:
+			return m_is_usbtuner;
 		case iFrontendInformation_ENUMS::frontendStatus:
 		{
 			unsigned int status;
diff --git a/lib/dvb/frontend.h b/lib/dvb/frontend.h
index c6c74d7d56..4ee8b3b876 100644
--- a/lib/dvb/frontend.h
+++ b/lib/dvb/frontend.h
@@ -86,6 +86,7 @@ private:
 	bool m_simulate;
 	bool m_enabled;
 	bool m_fbc;
+	bool m_is_usbtuner;
 	eDVBFrontend *m_simulate_fe; // only used to set frontend type in dvb.cpp
 	int m_type;
 	int m_dvbid;
@@ -181,6 +182,7 @@ public:
 	void set_FBCTuner(bool yesno) { m_fbc = yesno; }
 	bool getEnabled() { return m_enabled; }
 	void setEnabled(bool enable) { m_enabled = enable; }
+	void setUSBTuner(bool yesno) { m_is_usbtuner = yesno; }
 	bool is_multistream();
 	std::string getCapabilities();
 };
diff --git a/lib/dvb/idvb.h b/lib/dvb/idvb.h
index 0e140f9ef7..d6a8994520 100644
--- a/lib/dvb/idvb.h
+++ b/lib/dvb/idvb.h
@@ -698,6 +698,7 @@ public:
 	virtual RESULT getCAAdapterID(uint8_t &id)=0;
 	virtual RESULT flush()=0;
 	virtual int openDVR(int flags)=0;
+	virtual int getSource()=0;
 };
 
 class iTSMPEGDecoder: public iObject
@@ -748,6 +749,14 @@ public:
 		/** Display any complete data as fast as possible */
 	virtual RESULT setTrickmode()=0;
 
+	virtual RESULT prepareFCC(int fe_id, int vpid, int vtype, int pcrpid)=0;
+
+	virtual RESULT fccDecoderStart()=0;
+
+	virtual RESULT fccDecoderStop()=0;
+
+	virtual RESULT fccUpdatePids(int fe_id, int vpid, int vtype, int pcrpid)=0;
+
 	virtual RESULT getPTS(int what, pts_t &pts) = 0;
 
 	virtual RESULT showSinglePic(const char *filename) = 0;
diff --git a/lib/dvb/pmt.cpp b/lib/dvb/pmt.cpp
index e29087462d..26a0993cc1 100644
--- a/lib/dvb/pmt.cpp
+++ b/lib/dvb/pmt.cpp
@@ -32,6 +32,8 @@ eDVBServicePMTHandler::eDVBServicePMTHandler()
 	m_pmt_pid = -1;
 	m_dsmcc_pid = -1;
 	m_service_type = livetv;
+	m_ca_disabled = false;
+	m_pmt_ready = false;
 	eDVBResourceManager::getInstance(m_resourceManager);
 	CONNECT(m_PAT.tableReady, eDVBServicePMTHandler::PATready);
 	CONNECT(m_AIT.tableReady, eDVBServicePMTHandler::AITready);
@@ -150,6 +152,7 @@ void eDVBServicePMTHandler::PMTready(int error)
 		serviceEvent(eventNoPMT);
 	else
 	{
+		m_pmt_ready = true;
 		m_have_cached_program = false;
 		serviceEvent(eventNewProgramInfo);
 		switch (m_service_type)
@@ -174,8 +177,11 @@ void eDVBServicePMTHandler::PMTready(int error)
 			{
 				registerCAService();
 			}
-			eDVBCIInterfaces::getInstance()->recheckPMTHandlers();
-			eDVBCIInterfaces::getInstance()->gotPMT(this);
+			if (!m_ca_disabled)
+			{
+				eDVBCIInterfaces::getInstance()->recheckPMTHandlers();
+				eDVBCIInterfaces::getInstance()->gotPMT(this);
+			}
 		}
 		if (m_ca_servicePtr)
 		{
@@ -646,6 +652,9 @@ int eDVBServicePMTHandler::getProgramInfo(program &program)
 		{
 			program.pmtPid = pmtpid;
 		}
+
+		program.isCached = true;
+
 		if ( vpidtype == -1 )
 			vpidtype = videoStream::vtMPEG2;
 		if ( cached_vpid != -1 )
@@ -901,11 +910,14 @@ int eDVBServicePMTHandler::tuneExt(eServiceReferenceDVB &ref, ePtr<iTsSource> &s
 		if (!simulate)
 			eDebug("[eDVBServicePMTHandler] allocate Channel: res %d", res);
 
+		if (!res)
+			serviceEvent(eventChannelAllocated);
+
 		ePtr<iDVBChannelList> db;
 		if (!m_resourceManager->getChannelList(db))
 			db->getService((eServiceReferenceDVB&)m_reference, m_service);
 
-		if (!res && !simulate)
+		if (!res && !simulate && !m_ca_disabled)
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
@@ -1038,3 +1050,24 @@ void eDVBServicePMTHandler::free()
 	m_pvr_channel = 0;
 	m_demux = 0;
 }
+
+void eDVBServicePMTHandler::addCaHandler()
+{
+	m_ca_disabled = false;
+	if (m_channel)
+	{
+		eDVBCIInterfaces::getInstance()->addPMTHandler(this);
+		if (m_pmt_ready)
+		{
+			eDVBCIInterfaces::getInstance()->recheckPMTHandlers();
+			eDVBCIInterfaces::getInstance()->gotPMT(this);
+		}
+	}
+}
+
+void eDVBServicePMTHandler::removeCaHandler()
+{
+	m_ca_disabled = true;
+	if (m_channel)
+		eDVBCIInterfaces::getInstance()->removePMTHandler(this);
+}
diff --git a/lib/dvb/pmt.h b/lib/dvb/pmt.h
index e47589946c..b9aec9a0cd 100644
--- a/lib/dvb/pmt.h
+++ b/lib/dvb/pmt.h
@@ -82,6 +82,9 @@ class eDVBServicePMTHandler: public eDVBPMTParser
 	int m_use_decode_demux;
 	uint8_t m_decode_demux_num;
 	ePtr<eTimer> m_no_pat_entry_delay;
+
+	bool m_pmt_ready;
+	bool m_ca_disabled;
 public:
 	eDVBServicePMTHandler();
 	~eDVBServicePMTHandler();
@@ -112,6 +115,7 @@ public:
 		eventHBBTVInfo, /* HBBTV information was detected in the AIT */
 
 		eventStopped,
+		eventChannelAllocated,
 	};
 #ifndef SWIG
 	sigc::signal<void(int)> serviceEvent;
@@ -131,6 +135,7 @@ public:
 	void resetCachedProgram() { m_have_cached_program = false; }
 	void sendEventNoPatEntry();
 	void getHBBTVUrl(std::string &ret) const { ret = m_HBBTVUrl; }
+	void setCaDisable(bool disable) { m_ca_disabled = disable; }
 
 	enum serviceType
 	{
@@ -154,6 +159,8 @@ public:
 	int tuneExt(eServiceReferenceDVB &ref, ePtr<iTsSource> &, const char *streaminfo_file, eCueSheet *sg=0, bool simulate=false, eDVBService *service = 0, serviceType type = livetv, bool descramble = true);
 
 	void free();
+	void addCaHandler();
+	void removeCaHandler();
 private:
 	bool m_have_cached_program;
 	program m_cached_program;
diff --git a/lib/dvb/pmtparse.cpp b/lib/dvb/pmtparse.cpp
index 5dff96c731..9e8293ebd4 100644
--- a/lib/dvb/pmtparse.cpp
+++ b/lib/dvb/pmtparse.cpp
@@ -29,6 +29,8 @@ void eDVBPMTParser::clearProgramInfo(program &program)
 	program.pmtPid = -1;
 	program.textPid = -1;
 	program.aitPid = -1;
+	program.isCached = false;
+	program.pmtVersion = -1;
 	program.dsmccPid = -1;
 	program.serviceId = -1;
 	program.adapterId = -1;
@@ -67,6 +69,7 @@ int eDVBPMTParser::getProgramInfo(program &program)
 		eDVBTableSpec table_spec;
 		ptr->getSpec(table_spec);
 		program.pmtPid = table_spec.pid < 0x1fff ? table_spec.pid : -1;
+		program.pmtVersion = table_spec.version;
 
 		for (const auto i : ptr->getSections())
 		{
diff --git a/lib/dvb/pmtparse.h b/lib/dvb/pmtparse.h
index 3374355b87..8e82ead877 100644
--- a/lib/dvb/pmtparse.h
+++ b/lib/dvb/pmtparse.h
@@ -90,6 +90,8 @@ public:
 		int serviceId;
 		int adapterId;
 		int demuxId;
+		int pmtVersion;
+		bool isCached;
 		bool isCrypted() { return !caids.empty(); }
 	};
 
diff --git a/lib/nav/core.cpp b/lib/nav/core.cpp
index 22fe033586..41ea421265 100644
--- a/lib/nav/core.cpp
+++ b/lib/nav/core.cpp
@@ -1,6 +1,7 @@
 #include <lib/nav/core.h>
 #include <lib/base/eerror.h>
 #include <lib/python/python.h>
+#include <lib/dvb/fcc.h>
 
 eNavigation* eNavigation::instance;
 
@@ -26,10 +27,15 @@ void eNavigation::recordEvent(iRecordableService* service, int event)
 
 RESULT eNavigation::playService(const eServiceReference &service)
 {
-	stopService();
+	RESULT res = -1;
+
+	if (! m_fccmgr || m_fccmgr->tryFCCService(service, m_runningService) == -1)
+	{
+		stopService();
+		ASSERT(m_servicehandler);
+		res = m_servicehandler->play(service, m_runningService);
+	}
 
-	ASSERT(m_servicehandler);
-	RESULT res = m_servicehandler->play(service, m_runningService);
 	if (m_runningService)
 	{
 		m_runningService->setTarget(m_decoder);
@@ -72,6 +78,8 @@ RESULT eNavigation::stopService(void)
 
 		/* kill service. */
 	m_service_event_conn = 0;
+
+	m_fccmgr && m_fccmgr->cleanupFCCService();
 	return 0;
 }
 
@@ -160,6 +168,8 @@ eNavigation::eNavigation(iServiceHandler *serviceHandler, int decoder)
 	ASSERT(serviceHandler);
 	m_servicehandler = serviceHandler;
 	m_decoder = decoder;
+	if (decoder == 0 )
+		m_fccmgr = new eFCCServiceManager(this);
 	instance = this;
 }
 
diff --git a/lib/nav/core.h b/lib/nav/core.h
index accc007c0e..2334c553c3 100644
--- a/lib/nav/core.h
+++ b/lib/nav/core.h
@@ -6,6 +6,7 @@
 #include <connection.h>
 #include <map>
 #include <set>
+#include <lib/dvb/fcc.h>
 
 class eNavigation: public iObject, public sigc::trackable
 {
@@ -25,6 +26,9 @@ class eNavigation: public iObject, public sigc::trackable
 
 	sigc::signal<void(ePtr<iRecordableService>,int)> m_record_event;
 	void recordEvent(iRecordableService* service, int event);
+
+	friend class eFCCServiceManager;
+	ePtr<eFCCServiceManager> m_fccmgr;
 public:
 
 	RESULT playService(const eServiceReference &service);
diff --git a/lib/python/Components/ServiceList.py b/lib/python/Components/ServiceList.py
index 10b693ca05..cf69e41e1e 100644
--- a/lib/python/Components/ServiceList.py
+++ b/lib/python/Components/ServiceList.py
@@ -278,6 +278,9 @@ class ServiceList(GUIComponent):
 		self.l.getNext(r)
 		return r
 
+	def getList(self):
+		return self.l.getList()
+
 	def atBegin(self):
 		return self.instance.atBegin()
 
diff --git a/lib/python/Components/SystemInfo.py b/lib/python/Components/SystemInfo.py
index c32d476e9f..74f84778ee 100644
--- a/lib/python/Components/SystemInfo.py
+++ b/lib/python/Components/SystemInfo.py
@@ -279,6 +279,7 @@ SystemInfo["VideoModes"] = getChipSetString() in (  # 2160p and 1080p capable ha
 SystemInfo["FbcTunerPowerAlwaysOn"] = getBoxType() in ("vusolo4k", "vuduo4k", "vuduo4kse", "vuultimo4k", "vuuno4k", "vuuno4kse")
 SystemInfo["HasPhysicalLoopthrough"] = ["Vuplus DVB-S NIM(AVL2108)", "GIGA DVB-S2 NIM (Internal)"]
 SystemInfo["HasFBCtuner"] = ["Vuplus DVB-C NIM(BCM3158)", "Vuplus DVB-C NIM(BCM3148)", "Vuplus DVB-S NIM(7376 FBC)", "Vuplus DVB-S NIM(45308X FBC)", "Vuplus DVB-S NIM(45208 FBC)", "DVB-S2 NIM(45208 FBC)", "DVB-S2X NIM(45308X FBC)", "DVB-S2 NIM(45308 FBC)", "DVB-C NIM(3128 FBC)","BCM45208", "BCM45308X", "BCM3158"]
+SystemInfo["FCCactive"] = False
 SystemInfo["rc_model"] = rc_model.getRcFolder()
 SystemInfo["mapKeyInfoToEpgFunctions"] = SystemInfo["rc_model"] in ("vu", "vu2", "vu3", "vu4") # due to button limitations of the remote control
 SystemInfo["hasDuplicateVideoAndPvrButtons"] = SystemInfo["rc_model"] in ("edision3",) # Allow multiple functions only if both buttons are present
diff --git a/lib/python/Navigation.py b/lib/python/Navigation.py
index b83bec0615..db38aee8e6 100644
--- a/lib/python/Navigation.py
+++ b/lib/python/Navigation.py
@@ -38,6 +38,7 @@ class Navigation:
 		self.currentlyPlayingServiceReference = None
 		self.currentlyPlayingServiceOrGroup = None
 		self.currentlyPlayingService = None
+		self.skipServiceReferenceReset = False
 		self.RecordTimer = RecordTimer.RecordTimer()
 		self.PowerTimer = PowerTimer.PowerTimer()
 		self.__wasTimerWakeup = False
@@ -90,8 +91,9 @@ class Navigation:
 		for x in self.event:
 			x(i)
 		if i == iPlayableService.evEnd:
-			self.currentlyPlayingServiceReference = None
-			self.currentlyPlayingServiceOrGroup = None
+			if not self.skipServiceReferenceReset:
+				self.currentlyPlayingServiceReference = None
+				self.currentlyPlayingServiceOrGroup = None
 			self.currentlyPlayingService = None
 
 	def dispatchRecordEvent(self, rec_service, event):
@@ -164,7 +166,10 @@ class Navigation:
 			else:
 				playref = ref
 			if self.pnav:
-				self.pnav.stopService()
+				if not SystemInfo["FCCactive"]:
+					self.pnav.stopService()
+				else:
+					self.skipServiceReferenceReset = True
 				self.currentlyPlayingServiceReference = playref
 				self.currentlyPlayingServiceOrGroup = ref
 				if InfoBarInstance and InfoBarInstance.servicelist.servicelist.setCurrent(ref, adjust):
@@ -206,6 +211,7 @@ class Navigation:
 						self.retryServicePlayTimer = eTimer()
 						self.retryServicePlayTimer.callback.append(boundFunction(self.playService, ref, checkParentalControl, forceRestart, adjust))
 						self.retryServicePlayTimer.start(500, True)
+				self.skipServiceReferenceReset = False
 				if setPriorityFrontend:
 					setPreferredTuner(int(config.usage.frontend_priority.value))
 				return 0
diff --git a/lib/python/Plugins/SystemPlugins/FastChannelChange/Makefile.am b/lib/python/Plugins/SystemPlugins/FastChannelChange/Makefile.am
new file mode 100644
index 0000000000..ae91ed5776
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/FastChannelChange/Makefile.am
@@ -0,0 +1,7 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/FastChannelChange
+
+SUBDIRS = meta
+
+install_PYTHON =	\
+	__init__.py \
+	plugin.py
diff --git a/lib/python/Plugins/SystemPlugins/FastChannelChange/__init__.py b/lib/python/Plugins/SystemPlugins/FastChannelChange/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/Makefile.am b/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/Makefile.am
new file mode 100644
index 0000000000..4e3b9e942c
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/Makefile.am
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_fastchannelchange.xml
diff --git a/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/plugin_fastchannelchange.xml b/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/plugin_fastchannelchange.xml
new file mode 100644
index 0000000000..1527085fca
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/FastChannelChange/meta/plugin_fastchannelchange.xml
@@ -0,0 +1,16 @@
+<default>
+	  <prerequisites>
+                    <tag type="System" />
+	  </prerequisites>
+          <info>
+                    <author>hschang</author>
+                    <name>FastChannelChange</name>
+                    <packagename>enigma2-plugin-systemplugins-fastchannelchange</packagename>
+                    <shortdescription>Fast Channel Change</shortdescription>
+                    <description>Fast Channel Change</description>
+          </info>
+
+	  <files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-fastchannelchange" />
+	</files>
+</default>
diff --git a/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py b/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py
new file mode 100644
index 0000000000..570e036ca7
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/FastChannelChange/plugin.py
@@ -0,0 +1,576 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+from Screens.Screen import Screen
+from Screens.InfoBar import InfoBar
+from Components.config import config, getConfigListEntry, ConfigSubsection, ConfigYesNo, ConfigSelection
+from Components.ConfigList import ConfigListScreen
+from Components.Sources.StaticText import StaticText
+from Components.ServiceEventTracker import ServiceEventTracker
+from Components.SystemInfo import SystemInfo
+from enigma import iPlayableService, eTimer, eServiceReference, iRecordableService
+import os
+import glob
+from enigma import eFCCServiceManager
+
+g_max_fcc = len(glob.glob('/dev/fcc?'))
+g_default_fcc = (g_max_fcc) > 5 and 5 or g_max_fcc
+
+config.plugins.fccsetup = ConfigSubsection()
+config.plugins.fccsetup.activate = ConfigYesNo(default = False)
+config.plugins.fccsetup.maxfcc = ConfigSelection(default = str(g_default_fcc), choices = list((str(n), str(n)) for n in range(2, g_max_fcc+1)))
+config.plugins.fccsetup.zapupdown = ConfigYesNo(default = True)
+config.plugins.fccsetup.history = ConfigYesNo(default = False)
+config.plugins.fccsetup.priority = ConfigSelection(default = "zapupdown", choices = { "zapupdown" : _("Zap Up/Down"), "historynextback" : _("History Prev/Next") })
+config.plugins.fccsetup.disableforrec = ConfigYesNo(default = True)
+
+FccInstance = None
+
+def FCCChanged():
+	if FccInstance:
+		FccInstance.FCCSetupChanged()
+
+def checkSupportFCC():
+	global g_max_fcc
+	return bool(g_max_fcc)
+
+class FCCSupport:
+	def __init__(self, session):
+		self.session = session
+
+		self.fccmgr = eFCCServiceManager.getInstance();
+
+		self.fccList = []
+
+		self.createListTimer = eTimer()
+		self.createListTimer.callback.append(self.FCCCreateList)
+
+		self.getSrefTimer = eTimer()
+		self.getSrefTimer.callback.append(self.FCCGetCurSref)
+
+		self.eventList = []
+		self.fccEventTimer = eTimer()
+		self.fccEventTimer.callback.append(self.FCCApplyEvent)
+
+		self.fccForceStartTimer = eTimer()
+		self.fccForceStartTimer.callback.append(self.FCCForceStart)
+
+		self.fccResetTimer = eTimer()
+		self.fccResetTimer.callback.append(self.FCCResetTimerForREC)
+
+		self.activating = False
+
+		self.fccSetupActivate = checkSupportFCC() and config.plugins.fccsetup.activate.value
+		self.maxFCC = int(config.plugins.fccsetup.maxfcc.value)
+		self.zapdownEnable = config.plugins.fccsetup.zapupdown.value
+		self.historyEnable = config.plugins.fccsetup.history.value
+		self.priority = config.plugins.fccsetup.priority.value
+		self.disableforrec = config.plugins.fccsetup.disableforrec.value
+		self.fccmgr.setFCCEnable(int(self.fccSetupActivate))
+
+		self.setProcFCC(self.fccSetupActivate)
+		self.fccTimeoutTimer = eTimer()
+		self.fccTimeoutTimer.callback.append(self.FCCTimeout)
+		self.fccTimeoutEventCode = 0x102
+		self.fccTimeoutWait = None
+
+		self.fccmgr.m_fcc_event.get().append(self.FCCGetEvent)
+
+		self.getRecordings()
+
+		self.__event_tracker = None
+		self.onClose = []
+		self.changeEventTracker()
+		SystemInfo["FCCactive"] = self.fccSetupActivate
+#		from Screens.PictureInPicture import on_pip_start_stop
+#		on_pip_start_stop.append(self.FCCForceStopforPIP)
+
+	def setProcFCC(self, value):
+		procPath = "/proc/stb/frontend/fbc/fcc"
+		if os.access(procPath, os.W_OK):
+			open(procPath, 'w').write(value and "enable" or "disable")
+		else:
+			print("[FCCSupport] write fail! : ", procPath)
+
+	def gotRecordEvent(self, service, event):
+		if self.disableforrec:
+			if (not self.recordings) and (event == iRecordableService.evTuneStart):
+				self.getRecordings()
+				if self.recordings:
+					self.FCCForceStopForREC()
+
+			elif event == iRecordableService.evEnd:
+				self.getRecordings()
+				if not self.recordings:
+					self.FCCForceStart()
+		else:
+			if event == iRecordableService.evTuneStart:
+				self.FCCForceStopAndStart()
+
+			elif event == iRecordableService.evEnd:
+				self.fccForceStartTimer.stop()
+				self.fccResetTimer.start(2000, True)
+
+	def FCCForceStart(self):
+		self.enableEventTracker(True)
+		self.getEvStart()
+		self.getEvTunedIn()
+
+	def FCCForceStop(self):
+		self.enableEventTracker(False)
+		self.FCCDisableServices()
+		self.FCCStopAllServices()
+
+	def FCCForceStopAndStart(self):
+		self.fccResetTimer.stop()
+		self.FCCForceStop()
+		self.fccForceStartTimer.start(2000, True)
+
+	def FCCForceStopforPIP(self):
+		self.FCCForceStopAndStart()
+
+	def FCCForceStopForREC(self):
+		self.FCCForceStop()
+
+	def FCCResetTimerForREC(self):
+		self.FCCForceStopForREC()
+		self.FCCForceStart()
+
+	def FCCSetupChanged(self):
+		fcc_changed = False
+
+		newFccSetupActivate = checkSupportFCC() and config.plugins.fccsetup.activate.value
+		if self.fccSetupActivate != newFccSetupActivate:
+			self.fccSetupActivate = newFccSetupActivate
+			self.setProcFCC(self.fccSetupActivate)
+			fcc_changed = True
+
+		if int(config.plugins.fccsetup.maxfcc.value) != self.maxFCC:
+			self.maxFCC = int(config.plugins.fccsetup.maxfcc.value)
+			fcc_changed = True
+
+		if self.zapdownEnable != config.plugins.fccsetup.zapupdown.value:
+			self.zapdownEnable = config.plugins.fccsetup.zapupdown.value
+			fcc_changed = True
+
+		if self.historyEnable != config.plugins.fccsetup.history.value:
+			self.historyEnable = config.plugins.fccsetup.history.value
+			fcc_changed = True
+
+		if self.priority != config.plugins.fccsetup.priority.value:
+			self.priority = config.plugins.fccsetup.priority.value
+			fcc_changed = True
+
+		if self.disableforrec != config.plugins.fccsetup.disableforrec.value:
+			self.disableforrec = config.plugins.fccsetup.disableforrec.value
+			fcc_changed = True
+
+		self.getRecordings()
+		self.changeEventTracker()
+
+		if (not self.fccSetupActivate) or (self.disableforrec and self.recordings):
+			self.FCCDisableServices()
+
+		if fcc_changed:
+			self.fccmgr.setFCCEnable(int(self.fccSetupActivate))
+			SystemInfo["FCCactive"] = self.fccSetupActivate
+			curPlaying = self.session.nav.getCurrentlyPlayingServiceReference()
+			if curPlaying:
+				self.session.nav.stopService()
+				self.session.nav.playService(curPlaying)
+
+	# get current recording state
+	def getRecordings(self):
+		self.recordings = bool(self.session.nav.getRecordings())
+
+	def addRecordEventCallback(self, enable=True):
+		if enable:
+			if self.gotRecordEvent not in self.session.nav.record_event:
+				self.session.nav.record_event.append(self.gotRecordEvent)
+		else:
+			if self.gotRecordEvent in self.session.nav.record_event:
+				self.session.nav.record_event.remove(self.gotRecordEvent)
+
+	def changeEventTracker(self):
+		if self.fccSetupActivate:
+			self.addRecordEventCallback(True)
+			if self.disableforrec and self.recordings:
+				self.enableEventTracker(False)
+			else:
+				self.enableEventTracker(True)
+		else:
+			self.addRecordEventCallback(False)
+			self.enableEventTracker(False)
+
+	def enableEventTracker(self, activate):
+		if activate:
+			if not self.__event_tracker:
+				self.__event_tracker = ServiceEventTracker(screen=self, eventmap=
+				{
+					iPlayableService.evStart: self.getEvStart,
+					iPlayableService.evEnd: self.getEvEnd,
+					iPlayableService.evTunedIn: self.getEvTunedIn,
+					iPlayableService.evTuneFailed: self.getEvTuneFailed
+					})
+
+		elif self.__event_tracker:
+			# run ServiceEventTracker.__del_event()
+			for x in self.onClose:
+				x()
+
+			self.onClose = []
+			self.__event_tracker = None
+
+	def getEvStart(self):
+		self.createListTimer.start(0, True)
+
+	def getEvEnd(self):
+		self.FCCDisableServices()
+
+	def getEvTunedIn(self):
+		self.FCCTryStart()
+
+	def getEvTuneFailed(self):
+		self.FCCTryStart()
+
+	def isPlayableFCC(self, sref):
+		playable = True
+		if isinstance(sref, str):
+			sref = eServiceReference(sref)
+
+		if sref.type != 1:
+			playable = False
+
+		elif sref.getPath(): # is PVR? or streaming?
+			playable = False
+
+		elif int(sref.getData(0)) in (2, 10): # is RADIO?
+			playable = False
+
+		return playable
+
+	def getZapUpDownList(self):
+		fccZapUpDownList = []
+		serviceList = InfoBar.instance.servicelist.servicelist.getList()
+		curServiceRef = InfoBar.instance.servicelist.servicelist.getCurrent().toString()
+
+		serviceRefList = []
+		for idx in range(len(serviceList)):
+			sref = serviceList[idx].toString()
+			if (sref.split(':')[1] == '0') and self.isPlayableFCC(sref) : # remove marker
+				serviceRefList.append(sref)
+
+		if curServiceRef in serviceRefList:
+			serviceRefListSize = len(serviceRefList)
+			curServiceIndex = serviceRefList.index(curServiceRef)
+
+			for x in range(self.maxFCC-1):
+				if x > (serviceRefListSize-2): # if not ((x+1) <= (serviceRefListSize-1))
+					break
+
+				idx = (x // 2) + 1
+				if x % 2:
+					idx *= -1 # idx : [ 1, -1, 2, -2, 3, -3, 4, -4 ....]
+				idx = (curServiceIndex+idx) % serviceRefListSize # calc wraparound
+				try:
+					fccZapUpDownList.append(serviceRefList[idx])
+				except:
+					print("[FCCCreateList] append error, idx : %d" % idx)
+					break
+
+		return fccZapUpDownList
+
+	def getHistoryPrevNextList(self):
+		historyList = []
+		history = InfoBar.instance.servicelist.history[:]
+		history_pos = InfoBar.instance.servicelist.history_pos
+		history_len = len(history)
+
+		if history_len > 1 and history_pos > 0:
+			historyPrev = history[history_pos-1][:][-1].toString()
+			if self.isPlayableFCC(historyPrev):
+				historyList.append(historyPrev)
+
+		if history_len > 1 and history_pos < (history_len-1):
+			historyNext = history[history_pos+1][:][-1].toString()
+			if self.isPlayableFCC(historyNext):
+				historyList.append(historyNext)
+
+		return historyList
+
+	def FCCCreateList(self):
+		if (not self.fccSetupActivate) or (self.disableforrec and self.recordings):
+			return
+
+		if InfoBar.instance:
+			self.fccList = []
+			fccZapUpDownList = []
+			historyList = []
+
+			if self.zapdownEnable:
+				fccZapUpDownList = self.getZapUpDownList()
+
+			if self.historyEnable:
+				historyList = self.getHistoryPrevNextList()
+
+			if self.priority == "zapupdown":
+				fccZapDownLen = len(fccZapUpDownList)
+				if fccZapDownLen:
+					size = fccZapDownLen > 2 and 2 or fccZapDownLen
+					self.fccList = fccZapUpDownList[:size]
+					fccZapUpDownList = fccZapUpDownList[size:]
+
+				self.addFCCList(historyList)
+				self.addFCCList(fccZapUpDownList)
+			else:
+				self.addFCCList(historyList)
+				self.addFCCList(fccZapUpDownList)
+
+			self.FCCReconfigureFccList()
+
+	def addFCCList(self, newlist):
+		fccListMaxLen = self.maxFCC-1
+		for sref in newlist:
+			if len(self.fccList) >= fccListMaxLen:
+				break
+
+			if sref not in self.fccList:
+				self.fccList.append(sref)
+
+	def FCCReconfigureFccList(self):
+		stopFCCList = []
+		currentFCCList = self.fccmgr.getFCCServiceList()
+
+		for (sref, value) in currentFCCList.items():
+			state = value[0]
+
+			if state == 2: # fcc_state_failed
+				stopFCCList.append(sref)
+
+			elif sref in self.fccList: # check conflict FCC channel (decoder/prepare)
+				self.fccList.remove(sref)
+
+			elif state == 0: # fcc_state_preparing
+				stopFCCList.append(sref)
+
+		for sref in stopFCCList:
+			self.fccmgr.stopFCCService(eServiceReference(sref))
+
+	def FCCTryStart(self):
+		self.getSrefTimer.start(0, True)
+
+	def FCCGetCurSref(self):
+		if (not self.fccSetupActivate) or (self.disableforrec and self.recordings):
+			return
+
+		if self.createListTimer.isActive():
+			self.createListTimer.stop()
+			self.FCCCreateList()
+
+		curSref = self.session.nav.getCurrentlyPlayingServiceReference()
+
+		if curSref and self.isPlayableFCC(curSref):
+			self.FCCStart()
+		else:
+			print("[FCCSupport] FCCGetCurSref get current serviceReference failed!!")
+
+	def FCCStart(self):
+		self.activating = True
+		self.FCCGetEvent(iPlayableService.evTunedIn)
+
+	def FCCGetEvent(self, event):
+		if self.activating and event in (iPlayableService.evTunedIn, iPlayableService.evTuneFailed, iPlayableService.evFccFailed, self.fccTimeoutEventCode):
+			self.eventList.append(event)
+			self.fccEventTimer.start(0, True)
+
+	def FCCApplyEvent(self):
+		if not self.activating:
+			return
+
+		while self.eventList:
+			event = self.eventList.pop(0)
+
+			self.FCCTimeoutTimerStop()
+
+			if event in (iPlayableService.evTuneFailed, iPlayableService.evFccFailed):
+				self.fccmgr.stopFCCService() # stop FCC Services in failed state
+
+			if not self.FCCCheckAndTimerStart() and len(self.fccList):
+				sref = self.fccList.pop(0)
+				if self.isPlayableFCC(sref): # remove PVR, streaming, radio channels
+					self.fccmgr.playFCCService(eServiceReference(sref))
+					self.FCCTimeoutTimerStart(sref)
+
+	def FCCStopAllServices(self):
+		self.FCCTimeoutTimerStop()
+		fccServiceList = self.fccmgr.getFCCServiceList()
+		for (sref, value) in fccServiceList.items():
+			state = value[0]
+			if state != 1 : # 1  : fcc_state_decoding
+				self.fccmgr.stopFCCService(eServiceReference(sref))
+
+	def FCCDisableServices(self):
+		self.FCCTimeoutTimerStop()
+		self.getSrefTimer.stop()
+		self.activating = False
+		self.fccList = []
+
+		self.fccEventTimer.stop()
+		self.fccmgr.stopFCCService()
+		self.eventList = []
+
+	def FCCCheckNoLocked(self):
+		for (sref, value) in self.fccmgr.getFCCServiceList().items():
+			state = value[0]
+			locked = value[1]
+			if state != 1 and locked == 0: # no fcc decoding and no locked
+				return sref
+		return None
+
+	def FCCTimeout(self):
+		sref = self.FCCCheckNoLocked()
+		if sref and sref == self.fccTimeoutWait:
+			self.fccmgr.stopFCCService(eServiceReference(sref))
+			self.FCCGetEvent(self.fccTimeoutEventCode)
+
+	def FCCCheckAndTimerStart(self):
+		sref = self.FCCCheckNoLocked()
+		if sref:
+			self.FCCTimeoutTimerStart(sref)
+			return True
+		return False
+
+	def FCCTimeoutTimerStart(self, sref):
+		self.fccTimeoutWait = sref
+		self.fccTimeoutTimer.start(5000, True)
+
+	def FCCTimeoutTimerStop(self):
+		self.fccTimeoutWait = None
+		self.fccTimeoutTimer.stop()
+
+class FCCSetup(Screen, ConfigListScreen):
+	def __init__(self, session):
+		Screen.__init__(self, session)
+		self.title = _("Fast Channel Change Setup")
+		self.skinName = ["FCCSetup", "Setup"]
+		self.session = session
+		self.list = []
+		ConfigListScreen.__init__(self, self.list, session=self.session, on_change=self.setupChanged, fullUI=True)
+
+		self.isSupport = checkSupportFCC()
+
+		if self.isSupport:
+			self["description"] = StaticText("")
+			self.createConfig()
+			self.createSetup()
+		else:
+			self["description"] = StaticText(_("Receiver or driver does not support FCC"))
+
+	def createConfig(self):
+		self.enableEntry = getConfigListEntry(_("FCC enabled"), config.plugins.fccsetup.activate)
+		self.fccmaxEntry = getConfigListEntry(_("Max channels"), config.plugins.fccsetup.maxfcc)
+		self.zapupdownEntry = getConfigListEntry(_("Zap Up/Down"), config.plugins.fccsetup.zapupdown)
+		self.historyEntry = getConfigListEntry(_("History Prev/Next"), config.plugins.fccsetup.history)
+		self.priorityEntry = getConfigListEntry(_("priority"), config.plugins.fccsetup.priority)
+		self.recEntry = getConfigListEntry(_("Disable FCC during recordings"), config.plugins.fccsetup.disableforrec)
+
+	def createSetup(self):
+		self.list = []
+		self.list.append( self.enableEntry )
+		if self.enableEntry[1].value:
+			self.list.append( self.fccmaxEntry )
+			self.list.append( self.zapupdownEntry )
+			self.list.append( self.historyEntry )
+			if self.zapupdownEntry[1].value and self.historyEntry[1].value:
+				self.list.append( self.priorityEntry )
+			self.list.append(self.recEntry)
+
+		self["config"].list = self.list
+
+	def setupChanged(self):
+		currentEntry = self["config"].getCurrent()
+		if currentEntry in (self.zapupdownEntry, self.historyEntry, self.enableEntry):
+			if not (self.zapupdownEntry[1].value or self.historyEntry[1].value):
+				if currentEntry == self.historyEntry:
+					self.zapupdownEntry[1].value = True
+				else:
+					self.historyEntry[1].value = True
+			elif self.zapupdownEntry[1].value and self.historyEntry[1].value:
+				if int(self.fccmaxEntry[1].value) < 5:
+					if g_max_fcc < 5:
+						self.fccmaxEntry[1].value = str(g_max_fcc)
+					else:
+						self.fccmaxEntry[1].value = str(5)
+
+			self.createSetup()
+
+	def keySave(self):
+		if not self.isSupport:
+			self.keyCancel()
+			return
+
+		ConfigListScreen.keySave(self)
+		FCCChanged()
+
+def getExtensionName():
+	if config.plugins.fccsetup.activate.value:
+		return _("Disable Fast Channel Change")
+
+	return _("Enable Fast Channel Change")
+
+def ToggleUpdate():
+	if config.plugins.fccsetup.activate.value:
+		config.plugins.fccsetup.activate.value = False
+	else:
+		config.plugins.fccsetup.activate.value = True
+	config.plugins.fccsetup.activate.save()
+	FCCChanged()
+
+def FCCSupportInit(reason, **kwargs):
+	if "session" in kwargs:
+		global FccInstance
+		FccInstance = FCCSupport(kwargs["session"])
+
+def showFCCExtentionMenu():
+	currentScreenName = None
+	if FccInstance:
+		currentScreenName = FccInstance.session.current_dialog.__class__.__name__
+	return (currentScreenName == "InfoBar")
+
+def addExtentions(infobarExtensions):
+	infobarExtensions.addExtension((getExtensionName, ToggleUpdate, showFCCExtentionMenu), None)
+
+def FCCStart(session, **kwargs):
+	session.open(FCCSetup)
+
+def main(menuid, **kwargs):
+	if menuid == "scan":
+		return [(_("Fast Channel Change"), FCCStart, "FCCSetup", 5)]
+	else:
+		return []
+
+def Plugins(**kwargs):
+	list = []
+
+	global g_max_fcc
+	if g_max_fcc:
+		list.append(
+			PluginDescriptor(name="FCCSupport",
+			description="Fast Channel Change support",
+			where = [PluginDescriptor.WHERE_SESSIONSTART],
+			fnc = FCCSupportInit))
+
+		list.append(
+			PluginDescriptor(name="FCCExtensionMenu",
+			description="Fast Channel Change menu",
+			where = [PluginDescriptor.WHERE_EXTENSIONSINGLE],
+			fnc = addExtentions))
+
+		list.append(
+			PluginDescriptor(name=_("FCCSetup"),
+			description=_("Fast Channel Change setup"),
+			where = [PluginDescriptor.WHERE_MENU],
+			needsRestart = False,
+			fnc = main))
+
+	return list
diff --git a/lib/python/Plugins/SystemPlugins/Makefile.am b/lib/python/Plugins/SystemPlugins/Makefile.am
index 27281717a5..8fbea16704 100644
--- a/lib/python/Plugins/SystemPlugins/Makefile.am
+++ b/lib/python/Plugins/SystemPlugins/Makefile.am
@@ -5,7 +5,8 @@ SUBDIRS = PositionerSetup Satfinder \
 	DefaultServicesScanner CommonInterfaceAssignment \
 	VideoClippingSetup \
 	VideoEnhancement WirelessLan NetworkWizard \
-	SABnzbdSetup FastScan SatelliteEquipmentControl DiseqcTester
+	SABnzbdSetup FastScan SatelliteEquipmentControl DiseqcTester \
+	FastChannelChange
 
 if VUSOLO2
 SUBDIRS += CableScan
diff --git a/lib/python/enigma_python.i b/lib/python/enigma_python.i
index d0fdab6674..fa520bfd31 100644
--- a/lib/python/enigma_python.i
+++ b/lib/python/enigma_python.i
@@ -113,6 +113,7 @@ is usually caused by not marking PSignals as immutable.
 #include <lib/python/python.h>
 #include <lib/python/python_helpers.h>
 #include <lib/gdi/picload.h>
+#include <lib/dvb/fcc.h>
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -187,6 +188,7 @@ typedef long time_t;
 %immutable eHdmiCEC::addressChanged;
 %immutable ePythonMessagePump::recv_msg;
 %immutable eDVBLocalTimeHandler::m_timeUpdated;
+%immutable eFCCServiceManager::m_fcc_event;
 %immutable iCryptoInfo::clientname;
 %immutable iCryptoInfo::clientinfo;
 %immutable iCryptoInfo::verboseinfo;
@@ -261,6 +263,7 @@ typedef long time_t;
 %include <lib/python/python.h>
 %include <lib/python/pythonconfig.h>
 %include <lib/gdi/picload.h>
+%include <lib/dvb/fcc.h>
 %include <lib/dvb/streamserver.h>
 /**************  eptr  **************/
 
@@ -427,6 +430,15 @@ int getLinkedSlotID(int fe)
 }
 %}
 
+void setFCCEnable(int);
+%{
+void setFCCEnable(int enable)
+{
+        eFCCServiceManager *fcc_mng = eFCCServiceManager::getInstance();
+        if (fcc_mng) setFCCEnable(enable);
+}
+%}
+
 PyObject *getFontFaces();
 %{
 PyObject *getFontFaces()
diff --git a/lib/service/Makefile.inc b/lib/service/Makefile.inc
index 520b5edc69..6434d7b43e 100644
--- a/lib/service/Makefile.inc
+++ b/lib/service/Makefile.inc
@@ -9,6 +9,7 @@ service_libenigma_service_a_SOURCES = \
 	service/service.cpp \
 	service/servicedvb.cpp \
 	service/servicedvbrecord.cpp \
+	service/servicedvbfcc.cpp \
 	service/servicefs.cpp \
 	service/servicemp3.cpp \
 	service/servicemp3record.cpp \
@@ -27,6 +28,7 @@ serviceinclude_HEADERS = \
 	service/service.h \
 	service/servicedvb.h \
 	service/servicedvbrecord.h \
+	service/servicedvbfcc.h \
 	service/servicefs.h \
 	service/servicemp3.h \
 	service/servicemp3record.h \
diff --git a/lib/service/iservice.h b/lib/service/iservice.h
index 35fac0afe9..7f2a44367f 100644
--- a/lib/service/iservice.h
+++ b/lib/service/iservice.h
@@ -468,6 +468,7 @@ public:
 		syncState,
 		frontendNumber,
 		signalQualitydB,
+		isUsbTuner,
 		frontendStatus,
 		snrValue,
 		frequency,
@@ -964,6 +965,8 @@ public:
 
 		evVideoGammaChanged,
 
+		evFccFailed,
+
 		evUser = 0x100
 	};
 };
@@ -1022,6 +1025,8 @@ public:
 		evRecordFailed,
 		evRecordWriteError,
 		evNewEventInfo,
+		evTuneStart,
+		evPvrTuneStart,
 		evRecordAborted,
 		evGstRecordEnded,
 	};
diff --git a/lib/service/listboxservice.cpp b/lib/service/listboxservice.cpp
index e5d72be71a..2787cbd901 100644
--- a/lib/service/listboxservice.cpp
+++ b/lib/service/listboxservice.cpp
@@ -153,6 +153,17 @@ void eListboxServiceContent::getNext(eServiceReference &ref)
 		ref = eServiceReference();
 }
 
+PyObject *eListboxServiceContent::getList()
+{
+	ePyObject result = PyList_New(m_list.size());
+	int pos=0;
+	for (list::iterator it(m_list.begin()); it != m_list.end(); ++it)
+	{
+		PyList_SET_ITEM(result, pos++, NEW_eServiceReference(*it));
+	}
+	return result;
+}
+
 int eListboxServiceContent::getNextBeginningWithChar(char c)
 {
 //	printf("Char: %c\n", c);
diff --git a/lib/service/listboxservice.h b/lib/service/listboxservice.h
index 898354739a..36d5136276 100644
--- a/lib/service/listboxservice.h
+++ b/lib/service/listboxservice.h
@@ -23,6 +23,7 @@ public:
 	void getCurrent(eServiceReference &ref);
 	void getPrev(eServiceReference &ref);
 	void getNext(eServiceReference &ref);
+	PyObject *getList();
 
 	int getNextBeginningWithChar(char c);
 	int getPrevMarkerPos();
diff --git a/lib/service/servicedvb.cpp b/lib/service/servicedvb.cpp
index 91b0273288..e5d97096bd 100644
--- a/lib/service/servicedvb.cpp
+++ b/lib/service/servicedvb.cpp
@@ -19,6 +19,7 @@
 #include <lib/base/nconfig.h> // access to python config
 #include <lib/base/httpsstream.h>
 #include <lib/base/httpstream.h>
+#include <lib/service/servicedvbfcc.h>
 #include "servicepeer.h"
 
 		/* for subtitles */
@@ -30,6 +31,8 @@
 #include <byteswap.h>
 #include <netinet/in.h>
 
+#include <lib/dvb/fcc.h>
+
 #include <iostream>
 #include <fstream>
 using namespace std;
@@ -926,7 +929,10 @@ RESULT eServiceFactoryDVB::play(const eServiceReference &ref, ePtr<iPlayableServ
 	if (r)
 		service = 0;
 		// check resources...
-	ptr = new eDVBServicePlay(ref, service);
+	if (eFCCServiceManager::checkAvailable(ref))
+		ptr = new eDVBServiceFCCPlay(ref, service);
+	else
+		ptr = new eDVBServicePlay(ref, service);
 	return 0;
 }
 
@@ -1016,9 +1022,10 @@ RESULT eServiceFactoryDVB::lookupService(ePtr<eDVBService> &service, const eServ
 	return 0;
 }
 
-eDVBServicePlay::eDVBServicePlay(const eServiceReference &ref, eDVBService *service):
+eDVBServicePlay::eDVBServicePlay(const eServiceReference &ref, eDVBService *service, bool connect_event):
 	m_reference(ref),
 	m_dvb_service(service),
+	m_is_primary(1),
 	m_decoder_index(0),
 	m_have_video_pid(0),
 	m_tune_state(-1),
@@ -1044,7 +1051,8 @@ eDVBServicePlay::eDVBServicePlay(const eServiceReference &ref, eDVBService *serv
 //	m_is_streamx = m_is_stream;	// sets to false if looking at fallback url at this point as m_is_stream(ref.path.find("://") is false.
 	eDebug("[servicedvb][eDVBServicePlay] now running: m_is_streamx set by m_is_stream %d", m_is_streamx);
 	eDebug("[servicedvb][eDVBServicePlay] now running: m_is_pvr set to; %d", m_is_pvr);
-	CONNECT(m_service_handler.serviceEvent, eDVBServicePlay::serviceEvent);
+	if (connect_event)
+		CONNECT(m_service_handler.serviceEvent, eDVBServicePlay::serviceEvent);
 	CONNECT(m_service_handler_timeshift.serviceEvent, eDVBServicePlay::serviceEventTimeshift);
 	CONNECT(m_event_handler.m_eit_changed, eDVBServicePlay::gotNewEvent);
 	CONNECT(m_subtitle_sync_timer->timeout, eDVBServicePlay::checkSubtitleTiming);
@@ -1461,6 +1469,7 @@ RESULT eDVBServicePlay::stop()
 
 RESULT eDVBServicePlay::setTarget(int target, bool noaudio = false)
 {
+	m_is_primary = !target;
 	m_decoder_index = target;
 	m_noaudio = noaudio;
 	return 0;
@@ -2216,7 +2225,7 @@ int eDVBServicePlay::selectAudioStream(int i)
 
 	m_current_audio_pid = apid;
 
-	if (!m_noaudio && m_decoder->setAudioPID(apid, apidtype))
+	if ((m_is_primary || !m_noaudio) && m_decoder->setAudioPID(apid, apidtype))
 	{
 		eDebug("[eDVBServicePlay] set audio pid %04x failed", apid);
 		return -4;
@@ -2231,7 +2240,7 @@ int eDVBServicePlay::selectAudioStream(int i)
 	int rdsPid = apid;
 
 		/* if timeshift is not active and we are not in pip mode, check if we need to enable the rds reader */
-	if (!(m_timeshift_active || m_decoder_index || m_have_video_pid))
+	if (!(m_timeshift_active || m_decoder_index || m_have_video_pid || !m_is_primary))
 	{
 		int different_pid = program.videoStreams.empty() && program.audioStreams.size() == 1 && program.audioStreams[stream].rdsPid != -1;
 		if (different_pid)
diff --git a/lib/service/servicedvb.h b/lib/service/servicedvb.h
index ee97f458aa..c379a8ef38 100644
--- a/lib/service/servicedvb.h
+++ b/lib/service/servicedvb.h
@@ -174,7 +174,7 @@ public:
 	RESULT setNextPlaybackFile(const char *fn);
 	RESULT saveTimeshiftFile();
 	std::string getTimeshiftFilename();
-	void switchToLive();
+	virtual void switchToLive();
 
 		// iTapService
 	bool startTapToFD(int fd, const std::vector<int> &pids, int packetsize = 188);
@@ -209,6 +209,7 @@ protected:
 	ePtr<eDVBService> m_dvb_service;
 
 	ePtr<iTSMPEGDecoder> m_decoder;
+	int m_is_primary;
 	int m_decoder_index;
 	int m_have_video_pid;
 	int m_tune_state;
@@ -220,7 +221,7 @@ protected:
 	int m_current_audio_pid;
 	int m_current_video_pid_type;
 
-	eDVBServicePlay(const eServiceReference &ref, eDVBService *service);
+	eDVBServicePlay(const eServiceReference &ref, eDVBService *service, bool connect_event=true);
 
 		/* events */
 	void gotNewEvent(int error);
diff --git a/lib/service/servicedvbfcc.cpp b/lib/service/servicedvbfcc.cpp
new file mode 100644
index 0000000000..5494521807
--- /dev/null
+++ b/lib/service/servicedvbfcc.cpp
@@ -0,0 +1,501 @@
+#include <lib/service/servicedvbfcc.h>
+#include <lib/components/file_eraser.h>
+#include <lib/dvb/decoder.h>
+#include <lib/base/nconfig.h>
+
+eDVBServiceFCCPlay::eDVBServiceFCCPlay(const eServiceReference &ref, eDVBService *service)
+	:eDVBServicePlay(ref, service, false), m_fcc_flag(0), m_fcc_mode(fcc_mode_preparing), m_fcc_mustplay(false),
+		m_pmtVersion(-1), m_normal_decoding(false)
+{
+	CONNECT(m_service_handler.serviceEvent, eDVBServiceFCCPlay::serviceEvent);
+}
+
+eDVBServiceFCCPlay::~eDVBServiceFCCPlay()
+{
+}
+
+void eDVBServiceFCCPlay::serviceEvent(int event)
+{
+	if (!m_is_primary) // PIP mode
+	{
+		eDVBServicePlay::serviceEvent(event);
+		return;
+	}
+
+	m_tune_state = event;
+
+	switch (event)
+	{
+		case eDVBServicePMTHandler::eventTuned:
+		{
+			eDVBServicePlay::serviceEvent(event);
+			pushbackFCCEvents(evTunedIn);
+			break;
+		}
+		case eDVBServicePMTHandler::eventNoResources:
+		case eDVBServicePMTHandler::eventNoPAT:
+		case eDVBServicePMTHandler::eventNoPATEntry:
+		case eDVBServicePMTHandler::eventNoPMT:
+		case eDVBServicePMTHandler::eventTuneFailed:
+		case eDVBServicePMTHandler::eventMisconfiguration:
+		{
+			eDVBServicePlay::serviceEvent(event);
+			pushbackFCCEvents(evTuneFailed);
+			break;
+		}
+		case eDVBServicePMTHandler::eventChannelAllocated:
+		{
+			bool is_usb_tuner = checkUsbTuner();
+			bool fcc_state_decoding = getFCCStateDecoding();
+
+			if (is_usb_tuner)
+			{
+				if (fcc_state_decoding)
+				{
+					m_normal_decoding = true;
+					setNormalDecoding();
+				}
+				else
+				{
+					eDVBServicePlay::serviceEvent(eDVBServicePMTHandler::eventTuneFailed);
+					pushbackFCCEvents(evTuneFailed);
+				}
+			}
+			break;
+		}
+		case eDVBServicePMTHandler::eventNewProgramInfo:
+		{
+			if (m_fcc_flag & fcc_tune_failed)
+				return;
+
+			eDebug("[eDVBServiceFCCPlay] eventNewProgramInfo %d %d %d", m_timeshift_enabled, m_timeshift_active, m_normal_decoding);
+			if (m_normal_decoding)
+			{
+				eDVBServicePlay::serviceEvent(event);
+			}
+			else
+			{
+				if (m_timeshift_enabled)
+				updateTimeshiftPids();
+
+				if (!m_timeshift_active)
+					processNewProgramInfo();
+
+				if (!m_timeshift_active)
+				{
+					m_event((iPlayableService*)this, evUpdatedInfo);
+					pushbackFCCEvents(evUpdatedInfo);
+				}
+			}
+			break;
+		}
+		case eDVBServicePMTHandler::eventPreStart:
+		case eDVBServicePMTHandler::eventEOF:
+		case eDVBServicePMTHandler::eventSOF:
+		{
+			eDVBServicePlay::serviceEvent(event);
+			break;
+		}
+		case eDVBServicePMTHandler::eventHBBTVInfo:
+		{
+			eDVBServicePlay::serviceEvent(event);
+			pushbackFCCEvents(evHBBTVInfo);
+			break;
+		}
+	}
+}
+
+RESULT eDVBServiceFCCPlay::start()
+{
+	if (!m_is_primary) // PIP mode
+	{
+		eDVBServicePlay::start();
+		return 0;
+	}
+
+	if (m_fcc_flag & fcc_start) // already started
+	{
+		changeFCCMode();
+	}
+	else
+	{
+		m_fcc_flag |= fcc_start;
+		pushbackFCCEvents(evStart);
+
+		/* disable CA Interfaces on fcc_mode_preparing */
+		m_service_handler.setCaDisable(true);
+		eDVBServicePlay::start();
+	}
+	return 0;
+}
+
+void eDVBServiceFCCPlay::pushbackFCCEvents(int event)
+{
+	if (event == evTuneFailed)
+		m_fcc_flag |= fcc_tune_failed;
+	m_fcc_events.push_back(event);
+}
+
+void eDVBServiceFCCPlay::popFCCEvents()
+{
+	m_fcc_events.unique(); // remove duplicate evUpdatedInfo
+	for (std::list<int>::iterator it = m_fcc_events.begin(); it != m_fcc_events.end(); ++it)
+	{
+		if (*it == evUpdatedInfo)
+		{
+			updateFCCDecoder();
+			break;
+		}
+	}
+
+	/* add CaHandler */
+	m_service_handler.addCaHandler();
+
+	/* send events */
+	for (std::list<int>::iterator it = m_fcc_events.begin(); it != m_fcc_events.end(); ++it)
+	{
+		int event = *it;
+		m_event((iPlayableService*)this, event);
+	}
+}
+
+void eDVBServiceFCCPlay::changeFCCMode()
+{
+	if (m_fcc_mode == fcc_mode_decoding)
+	{
+		eDebug("[eDVBServiceFCCPlay] changeFCCMode [%s] disable FCC decoding.", m_reference.toString().c_str());
+		m_fcc_mode = fcc_mode_preparing;
+
+		/* stop timeshift */
+		eDVBServicePlay::stopTimeshift();
+
+		/* remove CaHandler */
+		m_service_handler.removeCaHandler();
+
+		if (m_fcc_flag & fcc_tune_failed)
+			m_event((iPlayableService*)this, evTuneFailed);
+
+		else if (m_fcc_flag & fcc_failed)
+			m_event((iPlayableService*)this, evFccFailed);
+
+		FCCDecoderStop();
+	}
+	else
+	{
+		eDebug("[eDVBServiceFCCPlay] changeFCCMode [%s] enable FCC decoding.", m_reference.toString().c_str());
+		m_fcc_mode = fcc_mode_decoding;
+		popFCCEvents();
+	}
+}
+
+void eDVBServiceFCCPlay::processNewProgramInfo(bool toLive)
+{
+	updateFCCDecoder(toLive);
+
+	if (m_fcc_flag & fcc_failed)
+	{
+		m_event((iPlayableService*)this, evFccFailed);
+	}
+}
+
+void eDVBServiceFCCPlay::updateFCCDecoder(bool sendSeekableStateChanged)
+{
+	eDebug("[eDVBServiceFCCPlay] updateFCCDecoder [%s]", m_reference.toString().c_str());
+	int vpid = -1, vpidtype = -1, pcrpid = -1, tpid = -1, achannel = -1, ac3_delay=-1, pcm_delay=-1;
+	bool isProgramInfoCached = false;
+	bool pmtVersionChanged = false;
+
+	eDVBServicePMTHandler &h = m_service_handler;
+
+	eDVBServicePMTHandler::program program;
+	if (h.getProgramInfo(program))
+		eDebug("[eDVBServiceFCCPlay] Getting program info failed.");
+	else
+	{
+		eDebugNoNewLine("have %zd video stream(s)", program.videoStreams.size());
+		if (!program.videoStreams.empty())
+		{
+			eDebugNoNewLine(" (");
+			for (std::vector<eDVBServicePMTHandler::videoStream>::const_iterator
+				i(program.videoStreams.begin());
+				i != program.videoStreams.end(); ++i)
+			{
+				if (vpid == -1)
+				{
+					vpid = i->pid;
+					vpidtype = i->type;
+				}
+				if (i != program.videoStreams.begin())
+					eDebugNoNewLine(", ");
+				eDebugNoNewLine("%04x", i->pid);
+			}
+			eDebugNoNewLine(")");
+		}
+		eDebugNoNewLine(", and %zd audio stream(s)", program.audioStreams.size());
+		if (!program.audioStreams.empty())
+		{
+			eDebugNoNewLine(" (");
+			for (std::vector<eDVBServicePMTHandler::audioStream>::const_iterator
+				i(program.audioStreams.begin());
+				i != program.audioStreams.end(); ++i)
+			{
+				if (i != program.audioStreams.begin())
+					eDebugNoNewLine(", ");
+				eDebugNoNewLine("%04x", i->pid);
+			}
+			eDebugNoNewLine(")");
+		}
+		eDebugNoNewLine(", and the pcr pid is %04x", program.pcrPid);
+		pcrpid = program.pcrPid;
+		eDebugNoNewLine(", and the text pid is %04x", program.textPid);
+		tpid = program.textPid;
+		eDebug(" %s", program.isCached ? "(Cached)":"");
+		isProgramInfoCached = program.isCached;
+		if (m_pmtVersion != program.pmtVersion)
+		{
+			if (m_pmtVersion != -1)
+				pmtVersionChanged = true;
+			m_pmtVersion = program.pmtVersion;
+			//eDebug("[eDVBServiceFCCPlay] updateFCCDecoder pmt version : %d", m_pmtVersion);
+		}
+	}
+
+	if (!m_decoder)
+	{
+		h.getDecodeDemux(m_decode_demux);
+		if (m_decode_demux)
+		{
+			m_decode_demux->getMPEGDecoder(m_decoder, m_decoder_index);
+			if (m_decoder)
+				m_decoder->connectVideoEvent(sigc::mem_fun(*this, &eDVBServiceFCCPlay::video_event), m_video_event_connection);
+		}
+		m_fcc_mustplay = true;
+	}
+
+	if (m_decoder)
+	{
+		if (!((m_fcc_flag & fcc_ready)||(m_fcc_flag & fcc_novideo)))
+		{
+			if (vpid == -1)
+			{
+				if (!isProgramInfoCached)
+					m_fcc_flag |= fcc_novideo;
+			}
+			else if ((vpidtype == -1) || (pcrpid== -1))
+			{
+				if (!isProgramInfoCached)
+					m_fcc_flag |= fcc_failed;
+			}
+			else if (!m_decoder->prepareFCC(m_decode_demux->getSource(), vpid, vpidtype, pcrpid))
+				m_fcc_flag |= fcc_ready;
+			else
+				m_fcc_flag |= fcc_failed;
+		}
+		else if (pmtVersionChanged)
+		{
+			m_decoder->fccUpdatePids(m_decode_demux->getSource(), vpid, vpidtype, pcrpid);
+			m_fcc_flag &=~fcc_decoding;
+		}
+	}
+
+	if (m_fcc_mode != fcc_mode_decoding)
+		return;
+
+	/* fcc_mode_decoding */
+	if (!(m_fcc_flag & fcc_ready) && !(m_fcc_flag & fcc_novideo))
+	{
+		eDebug("[eDVBServiceFCCPlay] updateFCCDecoder fcc is not ready.");
+		return;
+	}
+
+	if (m_decode_demux)
+	{
+		if (m_is_primary)
+		{
+			m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
+			m_teletext_parser->connectNewPage(sigc::mem_fun(*this, &eDVBServiceFCCPlay::newSubtitlePage), m_new_subtitle_page_connection);
+			m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
+			m_subtitle_parser->connectNewPage(sigc::mem_fun(*this, &eDVBServiceFCCPlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
+			if (m_timeshift_changed)
+			{
+				struct SubtitleTrack track;
+				if (getCachedSubtitle(track) >= 0)
+				{
+					if (track.type == 0) // dvb
+						m_subtitle_parser->start(track.pid, track.page_number, track.magazine_number);
+					else if (track.type == 1) // ttx
+						m_teletext_parser->setPageAndMagazine(track.page_number, track.magazine_number, track.language_code.c_str());
+				}
+			}
+		}
+	}
+
+	m_timeshift_changed = 0;
+
+	if (m_decoder)
+	{
+		bool wasSeekable = m_decoder->getVideoProgressive() != -1;
+
+		if (m_dvb_service)
+		{
+			achannel = m_dvb_service->getCacheEntry(eDVBService::cACHANNEL);
+			ac3_delay = m_dvb_service->getCacheEntry(eDVBService::cAC3DELAY);
+			pcm_delay = m_dvb_service->getCacheEntry(eDVBService::cPCMDELAY);
+		}
+		else // subservice
+		{
+			eServiceReferenceDVB ref;
+			m_service_handler.getServiceReference(ref);
+			eServiceReferenceDVB parent = ref.getParentServiceReference();
+			if (!parent)
+				parent = ref;
+			if (parent)
+			{
+				ePtr<eDVBResourceManager> res_mgr;
+				if (!eDVBResourceManager::getInstance(res_mgr))
+				{
+					ePtr<iDVBChannelList> db;
+					if (!res_mgr->getChannelList(db))
+					{
+						ePtr<eDVBService> origService;
+						if (!db->getService(parent, origService))
+						{
+		 					ac3_delay = origService->getCacheEntry(eDVBService::cAC3DELAY);
+							pcm_delay = origService->getCacheEntry(eDVBService::cPCMDELAY);
+						}
+					}
+				}
+			}
+		}
+
+		setAC3Delay(ac3_delay == -1 ? 0 : ac3_delay);
+		setPCMDelay(pcm_delay == -1 ? 0 : pcm_delay);
+
+		m_decoder->setVideoPID(vpid, vpidtype);
+		selectAudioStream();
+
+		if (!(m_is_pvr || m_is_stream || m_timeshift_active))
+			m_decoder->setSyncPCR(pcrpid);
+		else
+			m_decoder->setSyncPCR(-1);
+
+		if (m_is_primary)
+		{
+			m_decoder->setTextPID(tpid);
+			m_teletext_parser->start(program.textPid);
+		}
+
+		if (vpid > 0 && vpid < 0x2000)
+			;
+		else
+		{
+			std::string value;
+			bool showRadioBackground = eConfigManager::getConfigBoolValue("config.misc.showradiopic", true);
+			std::string radio_pic;
+			if (showRadioBackground)
+				radio_pic = eConfigManager::getConfigValue("config.misc.radiopic");
+			else
+				radio_pic = eConfigManager::getConfigValue("config.misc.blackradiopic");
+			m_decoder->setRadioPic(radio_pic);
+		}
+
+		/* fcc stop and decoder start */
+		if (!(m_fcc_flag & fcc_novideo))
+		{
+			if (m_fcc_flag & fcc_decoding)
+				;
+			else if(!m_decoder->fccDecoderStart())
+				m_fcc_flag |= fcc_decoding;
+		}
+
+		if (m_fcc_mustplay)
+		{
+			m_fcc_mustplay = false;
+			m_decoder->play();
+		}
+		else
+		{
+			m_decoder->set();
+		}
+
+		m_decoder->setAudioChannel(achannel);
+
+		/* don't worry about non-existing services, nor pvr services */
+		if (m_dvb_service)
+		{
+				/* (audio pid will be set in selectAudioTrack */
+			m_dvb_service->setCacheEntry(eDVBService::cVPID, vpid);
+			m_dvb_service->setCacheEntry(eDVBService::cVTYPE, vpidtype == eDVBVideo::MPEG2 ? -1 : vpidtype);
+			m_dvb_service->setCacheEntry(eDVBService::cPCRPID, pcrpid);
+			m_dvb_service->setCacheEntry(eDVBService::cTPID, tpid);
+		}
+		if (!sendSeekableStateChanged && (m_decoder->getVideoProgressive() != -1) != wasSeekable)
+			sendSeekableStateChanged = true;
+	}
+	m_have_video_pid = (vpid > 0 && vpid < 0x2000);
+
+	if (sendSeekableStateChanged)
+		m_event((iPlayableService*)this, evSeekableStatusChanged);
+}
+
+void eDVBServiceFCCPlay::FCCDecoderStop()
+{
+	eDebug("[eDVBServiceFCCPlay] FCCDecoderStop [%s]", m_reference.toString().c_str());
+
+	if (m_decoder)
+	{
+		m_teletext_parser = 0;
+		m_new_subtitle_page_connection = 0;
+		m_subtitle_parser = 0;
+		m_new_dvb_subtitle_page_connection = 0;
+
+		if (m_fcc_flag & fcc_ready)
+		{
+			m_decoder->fccDecoderStop();
+			m_fcc_flag &=~fcc_decoding;
+		}
+		else if (m_fcc_flag & fcc_novideo)
+		{
+			m_video_event_connection = 0;
+			m_decoder = 0;
+		}
+	}
+}
+
+void eDVBServiceFCCPlay::switchToLive()
+{
+	if (!m_timeshift_active)
+		return;
+
+	eDebug("[eDVBServiceFCCPlay] SwitchToLive");
+
+	resetTimeshift(0);
+
+	m_is_paused = m_skipmode = m_fastforward = m_slowmotion = 0; /* not supported in live mode */
+
+	/* free the timeshift service handler, we need the resources */
+	m_service_handler_timeshift.free();
+
+	m_fcc_flag &=~fcc_ready;
+	m_fcc_flag &=~fcc_decoding;
+	processNewProgramInfo(true);
+}
+
+bool eDVBServiceFCCPlay::checkUsbTuner()
+{
+	return (bool)getFrontendInfo(iFrontendInformation_ENUMS::isUsbTuner);
+}
+
+bool eDVBServiceFCCPlay::getFCCStateDecoding()
+{
+	eFCCServiceManager *fcc_service_mgr = eFCCServiceManager::getInstance();
+	return fcc_service_mgr->isStateDecoding((iPlayableService*)this);
+}
+
+void eDVBServiceFCCPlay::setNormalDecoding()
+{
+	eFCCServiceManager *fcc_service_mgr = eFCCServiceManager::getInstance();
+	return fcc_service_mgr->setNormalDecoding((iPlayableService*)this);
+}
+
+DEFINE_REF(eDVBServiceFCCPlay)
diff --git a/lib/service/servicedvbfcc.h b/lib/service/servicedvbfcc.h
new file mode 100644
index 0000000000..469b64cec1
--- /dev/null
+++ b/lib/service/servicedvbfcc.h
@@ -0,0 +1,53 @@
+#ifndef __servicedvbfcc_h
+#define __servicedvbfcc_h
+
+#include <lib/service/servicedvb.h>
+#include <list>
+
+#include <lib/dvb/fcc.h>
+
+class eDVBServiceFCCPlay: public eDVBServicePlay
+{
+	DECLARE_REF(eDVBServiceFCCPlay);
+public:
+	eDVBServiceFCCPlay(const eServiceReference &ref, eDVBService *service);
+	virtual ~eDVBServiceFCCPlay();
+	void serviceEvent(int event);
+	RESULT start();
+protected:
+	void pushbackFCCEvents(int event);
+	void popFCCEvents();
+	void changeFCCMode();
+	void processNewProgramInfo(bool toLive=false);
+	void updateFCCDecoder(bool sendSeekableStateChanged=false);
+	void FCCDecoderStop();
+	void switchToLive();
+	bool checkUsbTuner();
+	bool getFCCStateDecoding();
+	void setNormalDecoding();
+
+	bool m_fcc_enable;
+
+	enum {
+		fcc_start		= 1,
+		fcc_tune_failed	= 2,
+		fcc_failed		= 4,
+		fcc_ready		= 8,
+		fcc_decoding		= 16,
+		fcc_novideo		= 32,
+	};
+	int m_fcc_flag;
+
+	enum {
+		fcc_mode_preparing,
+		fcc_mode_decoding
+	};
+	int m_fcc_mode;
+
+	bool m_fcc_mustplay;
+	std::list<int> m_fcc_events;
+	int m_pmtVersion;
+	bool m_normal_decoding;
+};
+
+#endif /* __servicedvbfcc_h */
diff --git a/lib/service/servicedvbrecord.cpp b/lib/service/servicedvbrecord.cpp
index 94698bfcc6..c96c5f53e8 100644
--- a/lib/service/servicedvbrecord.cpp
+++ b/lib/service/servicedvbrecord.cpp
@@ -263,6 +263,11 @@ int eDVBServiceRecord::doPrepare()
 				f->open(m_ref.path.c_str());
 				source = ePtr<iTsSource>(f);
 			}
+			m_event((iRecordableService*)this, evPvrTuneStart);
+		}
+		else
+		{
+			m_event((iRecordableService*)this, evTuneStart);
 		}
 		return m_service_handler.tuneExt(m_ref, source, m_ref.path.c_str(), 0, m_simulate, NULL, servicetype, m_descramble);
 	}
